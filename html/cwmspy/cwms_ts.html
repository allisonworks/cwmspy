<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>cwmspy.cwms_ts API documentation</title>
<meta name="description" content="Facilities for working with time series" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cwmspy.cwms_ts</code></h1>
</header>
<section id="section-intro">
<p>Facilities for working with time series</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Facilities for working with time series
&#34;&#34;&#34;
import cx_Oracle
from cx_Oracle import DatabaseError
import datetime
import pandas as pd
from dateutil import tz
import pytz
import logging
from itertools import combinations
import numpy as np

from .utils import log_decorator


logger = logging.getLogger(__name__)
ld = log_decorator(logger)


class CwmsTsMixin:
    @staticmethod
    @ld
    def _convert_to_local_time(date, timezone=&#34;UTC&#34;):
        # reference: https://stackoverflow.com/a/4771733/4296857
        if date == None:
            return None
        from_zone = tz.gettz(timezone)
        utc = date.replace(tzinfo=from_zone)
        LOCAL_TIMEZONE = (
            datetime.datetime.now(datetime.timezone(datetime.timedelta(0)))
            .astimezone()
            .tzinfo
        )
        local_string = utc.astimezone(LOCAL_TIMEZONE).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        local = datetime.datetime.strptime(local_string, &#34;%Y-%m-%d %H:%M:%S&#34;)
        logger.debug(f&#34;Date converted to {local_string}&#34;)
        return local

    @ld
    def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
        &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.

        Parameters
        ----------
        p_cwms_ts_id : str
            CWMS time series identifier.
        p_db_office_code : int
            The unique numeric code identifying the office
                               owning the time series

        Returns
        -------
        str
            the unique numeric code value for the specified
                time series if successful, False otherwise.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_code(&#34;Some.fully.qualified.ts.id&#34;)
            &#34;04319021&#34;

        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            ts_code = cur.callfunc(
                &#34;cwms_ts.get_ts_code&#34;,
                cx_Oracle.STRING,
                [p_cwms_ts_id, p_db_office_code],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        logger.info(f&#34;get_ts_code returned {ts_code}&#34;)
        cur.close()

        return ts_code

    @ld
    def get_ts_max_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The latest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_ts_max_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            datetime.datetime(2019, 8, 16, 7, 0)
        ```
        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            max_date = cur.callfunc(
                &#34;cwms_ts.get_ts_max_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            logger.error(e)
            raise ValueError(e.__str__())
        logger.info(f&#34;max_date returned {max_date}&#34;)
        cur.close()

        return max_date

    @ld
    def get_ts_min_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS

        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_min_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)

            datetime.datetime(1975, 2, 18, 8, 0)
        ```
        &#34;&#34;&#34;

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            min_date = cur.callfunc(
                &#34;cwms_ts.get_ts_min_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        logger.info(f&#34;get_ts_min_date returned {min_date}&#34;)
        cur.close()

        return min_date

    @ld
    def retrieve_ts(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.


        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                                start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
        &gt;&gt;&gt; df.head()
                        date_time       value  quality_code
            0 2018-12-31 08:00:00  574.831986             0
            1 2019-01-01 08:00:00  668.277580             0
            2 2019-01-02 08:00:00  608.812202             0
            3 2019-01-03 08:00:00  597.485463             0
            4 2019-01-04 08:00:00  560.673563             0
        ```
        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        try:

            cur.callproc(
                &#34;cwms_ts.retrieve_ts&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]
        output_len = len(output)
        logger.info(f&#34;Found {output_len} records.&#34;)
        if local_tz:
            for i, v in enumerate(output):
                date = v[0]
                local = self._convert_to_local_time(date=date, timezone=p_timezone)

                output[i] = [local] + [x for x in v[1:]]

        if return_df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )

        return output

    @ld
    def store_ts(
        self,
        p_cwms_ts_id,
        p_units,
        times,
        values,
        qualities=None,
        format=None,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database using parameter types
            compatible with cx_Oracle Pyton package.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit of the data values.
        times : list
            The UTC times of the data values.  Can be string or type datetime
        values : list
            The data values.
        p_qualities : list
            The data quality codes for the data values.
        format : str
            strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
            parse all the way up to nanoseconds. See strftime documentation
            for more information on choices:
                https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
            store_ts will try to infer format if None.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;
        &gt;&gt;&gt; p_units = &#34;cms&#34;
        &gt;&gt;&gt; values = [1,2,3]
        &gt;&gt;&gt; p_qualities = [0,0,0]
        &gt;&gt;&gt; times = [&#39;2019/1/1&#39;,&#39;2019/1/2&#39;,&#39;2019/1/3&#39;]
        &gt;&gt;&gt; times = [datetime.datetime.strptime(x, &#34;%Y/%m/%d&#34;) for x in times]
        &gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
            True
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()

        p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

        t = pd.to_datetime(times, utc=True, infer_datetime_format=True, format=format)
        # Get the UTC times of the data values in Java milliseconds
        # this is what actually goes into Store_Ts
        zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
        p_times = [((time - zero).total_seconds() * 1000) for time in t]

        if not version_date:
            p_version_date = datetime.datetime(1111, 11, 11)
        else:
            p_version_date = version_date
        if not qualities:
            p_qualities = [0 for x in p_times]
        else:
            p_qualities = qualities

        try:

            cur.callproc(
                &#34;cwms_ts.store_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_units,
                    p_times,
                    p_values,
                    p_qualities,
                    p_store_rule,
                    p_override_prot,
                    p_version_date,
                    p_office_id,
                ],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @ld
    def store_by_df(
        self,
        df,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database with pandas.core.dataframe as input.

        Parameters
        ----------
        df : pandas.core.DataFrame
            Pandas DataFrame that requires `ts_id`, `date_time`, `units`,
            and `value` columns.  If optional column `quality_code` does not exist,
            all quality codes are assumed equal to 0.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            `True` for success

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_units = &#39;cms&#39;
        &gt;&gt;&gt; start_time = &#39;2019/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/8/1&#39;
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
        &gt;&gt;&gt;                     start_time=start_time,
        &gt;&gt;&gt;                     end_time=end_time,
        &gt;&gt;&gt;                     p_units=p_units
        &gt;&gt;&gt;                     )
        &gt;&gt;&gt; df[&#39;units&#39;] = p_units
        &gt;&gt;&gt; df[&#39;ts_id&#39;] = p_cwms_ts_id
        &gt;&gt;&gt; df[&#39;value&#39;] = df[&#39;value&#39;] / 1.1
        &gt;&gt;&gt; cwms.store_by_df(df)
            True
        ```

        &#34;&#34;&#34;

        if &#34;quality_code&#34; not in df.columns:
            df[&#34;quality_code&#34;] = 0

        grouped = df.groupby(&#34;ts_id&#34;)

        for p_cwms_ts_id, value in grouped:

            grpd = value.groupby(&#34;units&#34;)

            for p_units, val in grpd:
                # Only want to write new data to disk
                # Get current data, merge it for comparison

                # Add a little overlap to get current data
                min_date = (
                    val[&#34;date_time&#34;].min() - datetime.timedelta(days=1)
                ).strftime(&#34;%Y/%m/%d&#34;)
                max_date = (
                    val[&#34;date_time&#34;].max() + datetime.timedelta(days=1)
                ).strftime(&#34;%Y/%m/%d&#34;)

                # Will throw an error if time series identifier does not exist
                try:
                    logger.info(&#34;Get existing data if it does exist for comparison&#34;)
                    current_data = self.retrieve_ts(
                        p_cwms_ts_id=p_cwms_ts_id,
                        start_time=min_date,
                        end_time=max_date,
                        p_units=p_units,
                    )
                    logger.info(&#34;Merging with existing data to only write new values&#34;)
                    merged = val.merge(
                        current_data,
                        on=[&#34;date_time&#34;, &#34;value&#34;],
                        how=&#34;outer&#34;,
                        suffixes=[&#34;&#34;, &#34;_&#34;],
                        indicator=True,
                    )

                    # The data to store after comparing to current data
                    new_data = merged[merged[&#34;_merge&#34;] == &#34;left_only&#34;]
                    new_data_len = new_data.shape[0]
                    logger.info(f&#34;Loading {new_data_len} new values&#34;)
                except ValueError:
                    new_data = val.copy()
                self.store_ts(
                    p_cwms_ts_id=p_cwms_ts_id,
                    p_units=p_units,
                    times=list(new_data[&#34;date_time&#34;]),
                    values=list(new_data[&#34;value&#34;]),
                    qualities=list(new_data[&#34;quality_code&#34;]),
                    format=None,
                    p_store_rule=p_store_rule,
                    p_override_prot=p_override_prot,
                    version_date=version_date,
                    p_office_id=p_office_id,
                )
            return True

    @ld
    def delete_ts(
        self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
    ):
        &#34;&#34;&#34;Deletes a time series from the database.

        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_delete_action : type
            Specifies what to delete.
        p_db_office_id : type
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                            &#34;DELETE TS DATA&#34;)
            True
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    @ld
    def rename_ts(
        self,
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
            regular interval offset.

            Restrictions on changing include:
            - New time series identifier must agree with new/existing data
                interval and offset (regular/irregular)
            - Cannot change time utc offset if from one regular offset to
                another if time series data exists

        Parameters
        ----------
        p_cwms_ts_id_old : str
            The existing time series identifier.
        p_cwms_ts_id_new : str
            The new time series identifier.
        p_utc_offset_new : int
            The new offset into the utc data interval in minutes.
        p_office_id : str
            The office that owns the time series. If not specified or NULL,
                the session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; p_cwms_ts_id_old = &#34;Some.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; p_cwms_ts_id_new = &#34;New.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; cwms.rename_ts(
            p_cwms_ts_id_old,
            p_cwms_ts_id_new,
            p_utc_offset_new=None,
            p_office_id=None
            )
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.rename_ts&#34;,
                [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    @ld
    def delete_ts_window(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_override_protection=&#34;F&#34;,
        p_version_date=None,
        p_db_office_code=26,
    ):
        &#34;&#34;&#34;Delete ts with user specified start and end date.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            The version date of the data
        p_db_office_code : int
           The unique numeric code identifying the office owning the time
           series (the default is 26).

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; start_time = &#39;2018/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/2/1&#39;
        &gt;&gt;&gt; p_cwms_ts_id = &#39;your.cwms.ts.id&#39;
        &gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
        &gt;&gt;&gt;                      p_override_protection=&#39;F&#39;, p_version_date=None,
        &gt;&gt;&gt;                      p_db_office_code=26)
            True
        ```
        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        alter_session_sql = (
            &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
        )
        cur = self.conn.cursor()
        cur.execute(alter_session_sql)

        delete_sql = &#34;&#34;&#34;
                    delete from cwms_20.at_tsv_{}
                    where ts_code = {}
                    and date_time between to_date(&#39;{}&#39;) and to_date(&#39;{}&#39;)
                    &#34;&#34;&#34;
        if not p_override_protection:
            delete_sql += &#34;&#34;&#34;
                    and  quality_code not in (select quality_code from
                    cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                    &#34;&#34;&#34;

        ts_code = self.get_ts_code(
            p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
        )

        try:
            for year in range(p_start_time.year, (p_end_time.year + 1)):
                table = str(year)
                logger.info(f&#34;Deleteing {p_cwms_ts_id} from table {table}&#34;)
                sql = delete_sql.format(table, ts_code, start_time, end_time)
                if p_version_date:
                    sql += f&#34;and version_date = to_date(&#39;{p_version_date}&#39;)&#34;
                cur.execute(sql)
        except Exception as e:
            logger.error(e)
            cur.execute(&#34;rollback&#34;)
            cur.close()
            raise Exception(e.__str__())
        cur.execute(&#34;commit&#34;)
        cur.close()
        return True

    @ld
    def delete_by_df(
        self, df, p_override_protection=&#34;F&#34;, p_version_date=None, p_db_office_code=26
    ):
        &#34;&#34;&#34;Deletes time series data with a pandas.Core.DataFrame.

        Parameters
        ----------
        df : pandas.core.DataFrame
            A pandas data frame with columns `ts_id` and `date_time`.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : type
            The version date of the data.
        p_db_office_code : type
            The unique numeric code that identifies the office that owns the time series.

        Returns
        -------
        boolean
            True for success
        Examples
        -------
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.retrieve_ts(&#34;Some.Fully.Qualified.Cwms.pathname&#34;,&#34;2019/1/1&#34;,&#34;2019/9/1&#34;,&#34;cms&#34;,return_df=True)
        &gt;&gt;&gt; df[&#34;ts_id&#34;] = &#34;Some.Fully.Qualified.Cwms.pathname&#34;
        &gt;&gt;&gt; cwms.delete_by_df(df)
            True
        &#34;&#34;&#34;
        # A standard format between the database and script
        alter_session_sql = (
            &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
        )

        cur = self.conn.cursor()
        cur.execute(alter_session_sql)
        s = &#34;to_date(&#39;{}&#39;)&#34;
        df = df.copy()
        df[&#34;string_date_time&#34;] = [
            s.format(x.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)) for x in df[&#34;date_time&#34;]
        ]
        delete_sql = &#34;&#34;&#34;
                    delete from cwms_20.at_tsv_{}
                    where ts_code = {}
                    and date_time in {}
                    &#34;&#34;&#34;
        if not p_override_protection:
            delete_sql += &#34;&#34;&#34;
                    and  quality_code not in (select quality_code from
                    cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                    &#34;&#34;&#34;
        df.set_index(&#34;date_time&#34;, inplace=True)

        grouped = df.groupby(&#34;ts_id&#34;)

        # if any ts_id or year fails, all deletes will be rolled back
        try:

            for p_cwms_ts_id, value in grouped:
                grpd = value.groupby(pd.Grouper(freq=&#34;Y&#34;))

                # Get the ts_code by id because the at_tsv_YEAR tbls do not have
                # ts_ids
                ts_code = self.get_ts_code(
                    p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
                )

                # Group by year to go through all of the at_tsv_YEAR tbls
                for date, val in grpd:
                    value_len = str(val.shape[0])
                    year = str(date.year)
                    logger.info(
                        f&#34;Deleting {value_len} values from {p_cwms_ts_id} at table {year}&#34;
                    )
                    times = &#34;(&#34;
                    for time in list(val[&#34;string_date_time&#34;].values)[:-1]:
                        times += time + (&#34;,&#34;)
                    times += list(val[&#34;string_date_time&#34;].values)[-1] + &#34;)&#34;

                    sql = delete_sql.format(year, ts_code, times)

                    if p_version_date:
                        sql += &#34;and version_date = to_date(&#39;{}&#39;)&#34;.format(p_version_date)

                    cur.execute(sql)

        except Exception as e:
            logger.error(e)
            cur.execute(&#34;rollback&#34;)
            cur.close()
            raise Exception(e.__str__())
        cur.execute(&#34;commit&#34;)
        cur.close()
        return True

    @ld
    def get_extents(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
            the database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : int
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest and latest non-null dates in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_extents(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
        ```
        &#34;&#34;&#34;

        min_date = self.get_ts_min_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        max_date = self.get_ts_max_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        return min_date, max_date

    @ld
    def get_por(
        self,
        p_cwms_ts_id,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        pd.core.frame.DataFrame or list
            The period of record for given time series identifier

        Examples
        -------
        ```Python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.get_por(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        &gt;&gt;&gt; df.head()
                        date_time        value  quality_code
            0 1975-02-18 08:00:00   750.396435             3
            1 1975-02-19 08:00:00   750.396435             3
            2 1975-02-20 08:00:00  1403.666086             3
            3 1975-02-21 08:00:00  1613.210750             0
            4 1975-02-22 08:00:00  1765.272217             0
        ```

        &#34;&#34;&#34;

        mn, mx = self.get_extents(
            p_cwms_ts_id=p_cwms_ts_id,
            p_time_zone=p_timezone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        # To get a little overlap
        mn = mn - datetime.timedelta(days=1)
        mx = mx + datetime.timedelta(days=1)

        start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
        end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

        por = self.retrieve_ts(
            p_cwms_ts_id,
            start_time,
            end_time,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=&#34;F&#34;,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            return_df=return_df,
            local_tz=local_tz,
        )

        return por

    @ld
    def retrieve_multi_ts(
        self,
        p_cwms_ts_id_list,
        start_time=None,
        end_time=None,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
        local_tz=False,
        por=False,
        pivot=False,
    ):

        &#34;&#34;&#34;
        Retrieves time series data for a list of specified time series
            and time window or period of record.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        start_time : str
            The start of the time window in the specified or default time zone.
        end_time : str
            The end of the time window in the specified or default time zone.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        por : bool
            Return period of record.
        pivot : bool
            Pivot dataframe so cwms ts id&#39;s are columns.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;,
        &gt;&gt;&gt;                     &#39;Second.Fully.Qualified.Cwms.Ts.ID&#39;]
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, &#39;2019/1/1&#39;, &#39;2019/9/1&#39;)
        &gt;&gt;&gt; df.head()

                        date_time                                ts_id       value  quality_code
            0 2018-12-31 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      574.831986             0
            1 2019-01-01 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      668.277580             0
            2 2019-01-02 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      608.812202             0
            3 2019-01-03 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      597.485463             0
            4 2019-01-04 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      560.673563             0
        ```
        ```python
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
        &gt;&gt;&gt;                            &#39;2019/1/1&#39;,
        &gt;&gt;&gt;                            &#39;2019/9/1&#39;,
        &gt;&gt;&gt;                            pivot=True)
        &gt;&gt;&gt; df.head()

            ts_id                  &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;      &#39;Second.Fully.Qualified.Cwms.Ts.ID&#39;
            date_time
            2018-12-31 08:00:00                           574.831986                                     NaN
            2018-12-31 23:00:00                                  NaN                                     0.0
            2019-01-01 00:00:00                                  NaN                                     0.0
            2019-01-01 01:00:00                                  NaN                                     0.0
            2019-01-01 02:00:00                                  NaN                                     0.0
        ```
        &#34;&#34;&#34;

        l = []
        for i, ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[i]
            else:
                p_units = None

            arg = [
                p_units,
                p_timezone,
                &#34;F&#34;,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                version_date,
                p_max_version,
                p_office_id,
                return_df,
                local_tz,
            ]

            if por:
                args0 = [ts_id]
                args = args0 + arg
                rslt = self.get_por(*args)
            else:
                args0 = [ts_id, start_time, end_time]
                args = args0 + arg
                rslt = self.retrieve_ts(*args)

            if return_df:
                rslt[&#34;ts_id&#34;] = ts_id

            l.append(rslt)

        if return_df:
            l = pd.concat(l, ignore_index=True)
            l = l[[&#34;date_time&#34;, &#34;ts_id&#34;, &#34;value&#34;, &#34;quality_code&#34;]]
            if pivot:
                l = l.pivot(index=&#34;date_time&#34;, columns=&#34;ts_id&#34;, values=&#34;value&#34;)

        return l

    def compare_ts(
        self,
        p_cwms_ts_id_list,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        local_tz=False,
        only_diffs=True,
    ):
        &#34;&#34;&#34;
        Compares values across list of time series identifiers.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        only_diffs : bool
            Return only differences in timestamp values (the default is True).

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID-RAW&#39;,
        &gt;&gt;&gt;                     &#39;Some.Fully.Qualified.Cwms.Ts.ID-REV&#39;]
        &gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
        &gt;&gt;&gt; df.head()

                            Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                            value       quality_code    value   quality_code
            date_time                           
            1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
            1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
            1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
            1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
            1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
        ```
        &#34;&#34;&#34;
        df_list = []
        for idx, p_cwms_ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[idx]
            else:
                p_units = None
            df = self.get_por(
                p_cwms_ts_id,
                p_units=p_units,
                p_timezone=p_timezone,
                p_trim=p_trim,
                p_start_inclusive=p_start_inclusive,
                p_end_inclusive=p_end_inclusive,
                p_previous=p_previous,
                p_next=p_next,
                version_date=version_date,
                p_max_version=p_max_version,
                p_office_id=p_office_id,
                return_df=True,
                local_tz=local_tz,
            )
            df.set_index(&#34;date_time&#34;, inplace=True)
            df_list.append(df)

        # reference: https://stackoverflow.com/a/47112033/4296857
        comp = pd.concat(df_list, axis=&#34;columns&#34;, keys=p_cwms_ts_id_list)
        if only_diffs:
            df_list = []
            # np.isclose only accepts 2 arrays, getting a combination of all
            # possible arrays to compare
            comb = combinations(p_cwms_ts_id_list, 2)
            for i in comb:
                a, b = i
                bol = pd.DataFrame(
                    np.isclose(comp[a][&#34;value&#34;].values, comp[b][&#34;value&#34;].values)
                    == False
                )
                df_list.append(bol)
            bol = pd.concat(df_list, axis=1).apply(
                lambda row: True in row.values, axis=1
            )
            comp = comp[bol.values]
        return comp</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cwmspy.cwms_ts.CwmsTsMixin"><code class="flex name class">
<span>class <span class="ident">CwmsTsMixin</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CwmsTsMixin:
    @staticmethod
    @ld
    def _convert_to_local_time(date, timezone=&#34;UTC&#34;):
        # reference: https://stackoverflow.com/a/4771733/4296857
        if date == None:
            return None
        from_zone = tz.gettz(timezone)
        utc = date.replace(tzinfo=from_zone)
        LOCAL_TIMEZONE = (
            datetime.datetime.now(datetime.timezone(datetime.timedelta(0)))
            .astimezone()
            .tzinfo
        )
        local_string = utc.astimezone(LOCAL_TIMEZONE).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        local = datetime.datetime.strptime(local_string, &#34;%Y-%m-%d %H:%M:%S&#34;)
        logger.debug(f&#34;Date converted to {local_string}&#34;)
        return local

    @ld
    def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
        &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.

        Parameters
        ----------
        p_cwms_ts_id : str
            CWMS time series identifier.
        p_db_office_code : int
            The unique numeric code identifying the office
                               owning the time series

        Returns
        -------
        str
            the unique numeric code value for the specified
                time series if successful, False otherwise.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_code(&#34;Some.fully.qualified.ts.id&#34;)
            &#34;04319021&#34;

        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            ts_code = cur.callfunc(
                &#34;cwms_ts.get_ts_code&#34;,
                cx_Oracle.STRING,
                [p_cwms_ts_id, p_db_office_code],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        logger.info(f&#34;get_ts_code returned {ts_code}&#34;)
        cur.close()

        return ts_code

    @ld
    def get_ts_max_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The latest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_ts_max_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            datetime.datetime(2019, 8, 16, 7, 0)
        ```
        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            max_date = cur.callfunc(
                &#34;cwms_ts.get_ts_max_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            logger.error(e)
            raise ValueError(e.__str__())
        logger.info(f&#34;max_date returned {max_date}&#34;)
        cur.close()

        return max_date

    @ld
    def get_ts_min_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS

        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_min_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)

            datetime.datetime(1975, 2, 18, 8, 0)
        ```
        &#34;&#34;&#34;

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            min_date = cur.callfunc(
                &#34;cwms_ts.get_ts_min_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        logger.info(f&#34;get_ts_min_date returned {min_date}&#34;)
        cur.close()

        return min_date

    @ld
    def retrieve_ts(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.


        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                                start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
        &gt;&gt;&gt; df.head()
                        date_time       value  quality_code
            0 2018-12-31 08:00:00  574.831986             0
            1 2019-01-01 08:00:00  668.277580             0
            2 2019-01-02 08:00:00  608.812202             0
            3 2019-01-03 08:00:00  597.485463             0
            4 2019-01-04 08:00:00  560.673563             0
        ```
        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        try:

            cur.callproc(
                &#34;cwms_ts.retrieve_ts&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]
        output_len = len(output)
        logger.info(f&#34;Found {output_len} records.&#34;)
        if local_tz:
            for i, v in enumerate(output):
                date = v[0]
                local = self._convert_to_local_time(date=date, timezone=p_timezone)

                output[i] = [local] + [x for x in v[1:]]

        if return_df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )

        return output

    @ld
    def store_ts(
        self,
        p_cwms_ts_id,
        p_units,
        times,
        values,
        qualities=None,
        format=None,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database using parameter types
            compatible with cx_Oracle Pyton package.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit of the data values.
        times : list
            The UTC times of the data values.  Can be string or type datetime
        values : list
            The data values.
        p_qualities : list
            The data quality codes for the data values.
        format : str
            strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
            parse all the way up to nanoseconds. See strftime documentation
            for more information on choices:
                https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
            store_ts will try to infer format if None.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;
        &gt;&gt;&gt; p_units = &#34;cms&#34;
        &gt;&gt;&gt; values = [1,2,3]
        &gt;&gt;&gt; p_qualities = [0,0,0]
        &gt;&gt;&gt; times = [&#39;2019/1/1&#39;,&#39;2019/1/2&#39;,&#39;2019/1/3&#39;]
        &gt;&gt;&gt; times = [datetime.datetime.strptime(x, &#34;%Y/%m/%d&#34;) for x in times]
        &gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
            True
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()

        p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

        t = pd.to_datetime(times, utc=True, infer_datetime_format=True, format=format)
        # Get the UTC times of the data values in Java milliseconds
        # this is what actually goes into Store_Ts
        zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
        p_times = [((time - zero).total_seconds() * 1000) for time in t]

        if not version_date:
            p_version_date = datetime.datetime(1111, 11, 11)
        else:
            p_version_date = version_date
        if not qualities:
            p_qualities = [0 for x in p_times]
        else:
            p_qualities = qualities

        try:

            cur.callproc(
                &#34;cwms_ts.store_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_units,
                    p_times,
                    p_values,
                    p_qualities,
                    p_store_rule,
                    p_override_prot,
                    p_version_date,
                    p_office_id,
                ],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @ld
    def store_by_df(
        self,
        df,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database with pandas.core.dataframe as input.

        Parameters
        ----------
        df : pandas.core.DataFrame
            Pandas DataFrame that requires `ts_id`, `date_time`, `units`,
            and `value` columns.  If optional column `quality_code` does not exist,
            all quality codes are assumed equal to 0.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            `True` for success

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_units = &#39;cms&#39;
        &gt;&gt;&gt; start_time = &#39;2019/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/8/1&#39;
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
        &gt;&gt;&gt;                     start_time=start_time,
        &gt;&gt;&gt;                     end_time=end_time,
        &gt;&gt;&gt;                     p_units=p_units
        &gt;&gt;&gt;                     )
        &gt;&gt;&gt; df[&#39;units&#39;] = p_units
        &gt;&gt;&gt; df[&#39;ts_id&#39;] = p_cwms_ts_id
        &gt;&gt;&gt; df[&#39;value&#39;] = df[&#39;value&#39;] / 1.1
        &gt;&gt;&gt; cwms.store_by_df(df)
            True
        ```

        &#34;&#34;&#34;

        if &#34;quality_code&#34; not in df.columns:
            df[&#34;quality_code&#34;] = 0

        grouped = df.groupby(&#34;ts_id&#34;)

        for p_cwms_ts_id, value in grouped:

            grpd = value.groupby(&#34;units&#34;)

            for p_units, val in grpd:
                # Only want to write new data to disk
                # Get current data, merge it for comparison

                # Add a little overlap to get current data
                min_date = (
                    val[&#34;date_time&#34;].min() - datetime.timedelta(days=1)
                ).strftime(&#34;%Y/%m/%d&#34;)
                max_date = (
                    val[&#34;date_time&#34;].max() + datetime.timedelta(days=1)
                ).strftime(&#34;%Y/%m/%d&#34;)

                # Will throw an error if time series identifier does not exist
                try:
                    logger.info(&#34;Get existing data if it does exist for comparison&#34;)
                    current_data = self.retrieve_ts(
                        p_cwms_ts_id=p_cwms_ts_id,
                        start_time=min_date,
                        end_time=max_date,
                        p_units=p_units,
                    )
                    logger.info(&#34;Merging with existing data to only write new values&#34;)
                    merged = val.merge(
                        current_data,
                        on=[&#34;date_time&#34;, &#34;value&#34;],
                        how=&#34;outer&#34;,
                        suffixes=[&#34;&#34;, &#34;_&#34;],
                        indicator=True,
                    )

                    # The data to store after comparing to current data
                    new_data = merged[merged[&#34;_merge&#34;] == &#34;left_only&#34;]
                    new_data_len = new_data.shape[0]
                    logger.info(f&#34;Loading {new_data_len} new values&#34;)
                except ValueError:
                    new_data = val.copy()
                self.store_ts(
                    p_cwms_ts_id=p_cwms_ts_id,
                    p_units=p_units,
                    times=list(new_data[&#34;date_time&#34;]),
                    values=list(new_data[&#34;value&#34;]),
                    qualities=list(new_data[&#34;quality_code&#34;]),
                    format=None,
                    p_store_rule=p_store_rule,
                    p_override_prot=p_override_prot,
                    version_date=version_date,
                    p_office_id=p_office_id,
                )
            return True

    @ld
    def delete_ts(
        self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
    ):
        &#34;&#34;&#34;Deletes a time series from the database.

        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_delete_action : type
            Specifies what to delete.
        p_db_office_id : type
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                            &#34;DELETE TS DATA&#34;)
            True
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    @ld
    def rename_ts(
        self,
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
            regular interval offset.

            Restrictions on changing include:
            - New time series identifier must agree with new/existing data
                interval and offset (regular/irregular)
            - Cannot change time utc offset if from one regular offset to
                another if time series data exists

        Parameters
        ----------
        p_cwms_ts_id_old : str
            The existing time series identifier.
        p_cwms_ts_id_new : str
            The new time series identifier.
        p_utc_offset_new : int
            The new offset into the utc data interval in minutes.
        p_office_id : str
            The office that owns the time series. If not specified or NULL,
                the session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; p_cwms_ts_id_old = &#34;Some.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; p_cwms_ts_id_new = &#34;New.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; cwms.rename_ts(
            p_cwms_ts_id_old,
            p_cwms_ts_id_new,
            p_utc_offset_new=None,
            p_office_id=None
            )
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.rename_ts&#34;,
                [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
            )
        except DatabaseError as e:
            logger.error(e)
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    @ld
    def delete_ts_window(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_override_protection=&#34;F&#34;,
        p_version_date=None,
        p_db_office_code=26,
    ):
        &#34;&#34;&#34;Delete ts with user specified start and end date.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            The version date of the data
        p_db_office_code : int
           The unique numeric code identifying the office owning the time
           series (the default is 26).

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; start_time = &#39;2018/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/2/1&#39;
        &gt;&gt;&gt; p_cwms_ts_id = &#39;your.cwms.ts.id&#39;
        &gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
        &gt;&gt;&gt;                      p_override_protection=&#39;F&#39;, p_version_date=None,
        &gt;&gt;&gt;                      p_db_office_code=26)
            True
        ```
        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        alter_session_sql = (
            &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
        )
        cur = self.conn.cursor()
        cur.execute(alter_session_sql)

        delete_sql = &#34;&#34;&#34;
                    delete from cwms_20.at_tsv_{}
                    where ts_code = {}
                    and date_time between to_date(&#39;{}&#39;) and to_date(&#39;{}&#39;)
                    &#34;&#34;&#34;
        if not p_override_protection:
            delete_sql += &#34;&#34;&#34;
                    and  quality_code not in (select quality_code from
                    cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                    &#34;&#34;&#34;

        ts_code = self.get_ts_code(
            p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
        )

        try:
            for year in range(p_start_time.year, (p_end_time.year + 1)):
                table = str(year)
                logger.info(f&#34;Deleteing {p_cwms_ts_id} from table {table}&#34;)
                sql = delete_sql.format(table, ts_code, start_time, end_time)
                if p_version_date:
                    sql += f&#34;and version_date = to_date(&#39;{p_version_date}&#39;)&#34;
                cur.execute(sql)
        except Exception as e:
            logger.error(e)
            cur.execute(&#34;rollback&#34;)
            cur.close()
            raise Exception(e.__str__())
        cur.execute(&#34;commit&#34;)
        cur.close()
        return True

    @ld
    def delete_by_df(
        self, df, p_override_protection=&#34;F&#34;, p_version_date=None, p_db_office_code=26
    ):
        &#34;&#34;&#34;Deletes time series data with a pandas.Core.DataFrame.

        Parameters
        ----------
        df : pandas.core.DataFrame
            A pandas data frame with columns `ts_id` and `date_time`.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : type
            The version date of the data.
        p_db_office_code : type
            The unique numeric code that identifies the office that owns the time series.

        Returns
        -------
        boolean
            True for success
        Examples
        -------
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.retrieve_ts(&#34;Some.Fully.Qualified.Cwms.pathname&#34;,&#34;2019/1/1&#34;,&#34;2019/9/1&#34;,&#34;cms&#34;,return_df=True)
        &gt;&gt;&gt; df[&#34;ts_id&#34;] = &#34;Some.Fully.Qualified.Cwms.pathname&#34;
        &gt;&gt;&gt; cwms.delete_by_df(df)
            True
        &#34;&#34;&#34;
        # A standard format between the database and script
        alter_session_sql = (
            &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
        )

        cur = self.conn.cursor()
        cur.execute(alter_session_sql)
        s = &#34;to_date(&#39;{}&#39;)&#34;
        df = df.copy()
        df[&#34;string_date_time&#34;] = [
            s.format(x.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)) for x in df[&#34;date_time&#34;]
        ]
        delete_sql = &#34;&#34;&#34;
                    delete from cwms_20.at_tsv_{}
                    where ts_code = {}
                    and date_time in {}
                    &#34;&#34;&#34;
        if not p_override_protection:
            delete_sql += &#34;&#34;&#34;
                    and  quality_code not in (select quality_code from
                    cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                    &#34;&#34;&#34;
        df.set_index(&#34;date_time&#34;, inplace=True)

        grouped = df.groupby(&#34;ts_id&#34;)

        # if any ts_id or year fails, all deletes will be rolled back
        try:

            for p_cwms_ts_id, value in grouped:
                grpd = value.groupby(pd.Grouper(freq=&#34;Y&#34;))

                # Get the ts_code by id because the at_tsv_YEAR tbls do not have
                # ts_ids
                ts_code = self.get_ts_code(
                    p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
                )

                # Group by year to go through all of the at_tsv_YEAR tbls
                for date, val in grpd:
                    value_len = str(val.shape[0])
                    year = str(date.year)
                    logger.info(
                        f&#34;Deleting {value_len} values from {p_cwms_ts_id} at table {year}&#34;
                    )
                    times = &#34;(&#34;
                    for time in list(val[&#34;string_date_time&#34;].values)[:-1]:
                        times += time + (&#34;,&#34;)
                    times += list(val[&#34;string_date_time&#34;].values)[-1] + &#34;)&#34;

                    sql = delete_sql.format(year, ts_code, times)

                    if p_version_date:
                        sql += &#34;and version_date = to_date(&#39;{}&#39;)&#34;.format(p_version_date)

                    cur.execute(sql)

        except Exception as e:
            logger.error(e)
            cur.execute(&#34;rollback&#34;)
            cur.close()
            raise Exception(e.__str__())
        cur.execute(&#34;commit&#34;)
        cur.close()
        return True

    @ld
    def get_extents(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
            the database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : int
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest and latest non-null dates in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_extents(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
        ```
        &#34;&#34;&#34;

        min_date = self.get_ts_min_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        max_date = self.get_ts_max_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        return min_date, max_date

    @ld
    def get_por(
        self,
        p_cwms_ts_id,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        pd.core.frame.DataFrame or list
            The period of record for given time series identifier

        Examples
        -------
        ```Python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.get_por(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        &gt;&gt;&gt; df.head()
                        date_time        value  quality_code
            0 1975-02-18 08:00:00   750.396435             3
            1 1975-02-19 08:00:00   750.396435             3
            2 1975-02-20 08:00:00  1403.666086             3
            3 1975-02-21 08:00:00  1613.210750             0
            4 1975-02-22 08:00:00  1765.272217             0
        ```

        &#34;&#34;&#34;

        mn, mx = self.get_extents(
            p_cwms_ts_id=p_cwms_ts_id,
            p_time_zone=p_timezone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        # To get a little overlap
        mn = mn - datetime.timedelta(days=1)
        mx = mx + datetime.timedelta(days=1)

        start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
        end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

        por = self.retrieve_ts(
            p_cwms_ts_id,
            start_time,
            end_time,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=&#34;F&#34;,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            return_df=return_df,
            local_tz=local_tz,
        )

        return por

    @ld
    def retrieve_multi_ts(
        self,
        p_cwms_ts_id_list,
        start_time=None,
        end_time=None,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
        local_tz=False,
        por=False,
        pivot=False,
    ):

        &#34;&#34;&#34;
        Retrieves time series data for a list of specified time series
            and time window or period of record.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        start_time : str
            The start of the time window in the specified or default time zone.
        end_time : str
            The end of the time window in the specified or default time zone.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        por : bool
            Return period of record.
        pivot : bool
            Pivot dataframe so cwms ts id&#39;s are columns.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;,
        &gt;&gt;&gt;                     &#39;Second.Fully.Qualified.Cwms.Ts.ID&#39;]
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, &#39;2019/1/1&#39;, &#39;2019/9/1&#39;)
        &gt;&gt;&gt; df.head()

                        date_time                                ts_id       value  quality_code
            0 2018-12-31 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      574.831986             0
            1 2019-01-01 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      668.277580             0
            2 2019-01-02 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      608.812202             0
            3 2019-01-03 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      597.485463             0
            4 2019-01-04 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      560.673563             0
        ```
        ```python
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
        &gt;&gt;&gt;                            &#39;2019/1/1&#39;,
        &gt;&gt;&gt;                            &#39;2019/9/1&#39;,
        &gt;&gt;&gt;                            pivot=True)
        &gt;&gt;&gt; df.head()

            ts_id                  &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;      &#39;Second.Fully.Qualified.Cwms.Ts.ID&#39;
            date_time
            2018-12-31 08:00:00                           574.831986                                     NaN
            2018-12-31 23:00:00                                  NaN                                     0.0
            2019-01-01 00:00:00                                  NaN                                     0.0
            2019-01-01 01:00:00                                  NaN                                     0.0
            2019-01-01 02:00:00                                  NaN                                     0.0
        ```
        &#34;&#34;&#34;

        l = []
        for i, ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[i]
            else:
                p_units = None

            arg = [
                p_units,
                p_timezone,
                &#34;F&#34;,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                version_date,
                p_max_version,
                p_office_id,
                return_df,
                local_tz,
            ]

            if por:
                args0 = [ts_id]
                args = args0 + arg
                rslt = self.get_por(*args)
            else:
                args0 = [ts_id, start_time, end_time]
                args = args0 + arg
                rslt = self.retrieve_ts(*args)

            if return_df:
                rslt[&#34;ts_id&#34;] = ts_id

            l.append(rslt)

        if return_df:
            l = pd.concat(l, ignore_index=True)
            l = l[[&#34;date_time&#34;, &#34;ts_id&#34;, &#34;value&#34;, &#34;quality_code&#34;]]
            if pivot:
                l = l.pivot(index=&#34;date_time&#34;, columns=&#34;ts_id&#34;, values=&#34;value&#34;)

        return l

    def compare_ts(
        self,
        p_cwms_ts_id_list,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        local_tz=False,
        only_diffs=True,
    ):
        &#34;&#34;&#34;
        Compares values across list of time series identifiers.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        only_diffs : bool
            Return only differences in timestamp values (the default is True).

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID-RAW&#39;,
        &gt;&gt;&gt;                     &#39;Some.Fully.Qualified.Cwms.Ts.ID-REV&#39;]
        &gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
        &gt;&gt;&gt; df.head()

                            Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                            value       quality_code    value   quality_code
            date_time                           
            1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
            1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
            1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
            1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
            1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
        ```
        &#34;&#34;&#34;
        df_list = []
        for idx, p_cwms_ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[idx]
            else:
                p_units = None
            df = self.get_por(
                p_cwms_ts_id,
                p_units=p_units,
                p_timezone=p_timezone,
                p_trim=p_trim,
                p_start_inclusive=p_start_inclusive,
                p_end_inclusive=p_end_inclusive,
                p_previous=p_previous,
                p_next=p_next,
                version_date=version_date,
                p_max_version=p_max_version,
                p_office_id=p_office_id,
                return_df=True,
                local_tz=local_tz,
            )
            df.set_index(&#34;date_time&#34;, inplace=True)
            df_list.append(df)

        # reference: https://stackoverflow.com/a/47112033/4296857
        comp = pd.concat(df_list, axis=&#34;columns&#34;, keys=p_cwms_ts_id_list)
        if only_diffs:
            df_list = []
            # np.isclose only accepts 2 arrays, getting a combination of all
            # possible arrays to compare
            comb = combinations(p_cwms_ts_id_list, 2)
            for i in comb:
                a, b = i
                bol = pd.DataFrame(
                    np.isclose(comp[a][&#34;value&#34;].values, comp[b][&#34;value&#34;].values)
                    == False
                )
                df_list.append(bol)
            bol = pd.concat(df_list, axis=1).apply(
                lambda row: True in row.values, axis=1
            )
            comp = comp[bol.values]
        return comp</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cwmspy.core.CWMS" href="core.html#cwmspy.core.CWMS">CWMS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.compare_ts"><code class="name flex">
<span>def <span class="ident">compare_ts</span></span>(<span>self, p_cwms_ts_id_list, p_units_list=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, local_tz=False, only_diffs=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Compares values across list of time series identifiers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of time series identifiers.</dd>
<dt><strong><code>p_units_list</code></strong> :&ensp;<code>list</code></dt>
<dd>Unit list to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
<dt><strong><code>only_diffs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return only differences in timestamp values (the default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas</code> <code>df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy.core import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; p_cwms_ts_id_list = ['Some.Fully.Qualified.Cwms.Ts.ID-RAW',
&gt;&gt;&gt;                     'Some.Fully.Qualified.Cwms.Ts.ID-REV']
&gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
&gt;&gt;&gt; df.head()

                    Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                    value       quality_code    value   quality_code
    date_time                           
    1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
    1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
    1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
    1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
    1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compare_ts(
    self,
    p_cwms_ts_id_list,
    p_units_list=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    local_tz=False,
    only_diffs=True,
):
    &#34;&#34;&#34;
    Compares values across list of time series identifiers.

    Parameters
    ----------
    p_cwms_ts_id_list : list
        List of time series identifiers.
    p_units_list : list
        Unit list to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.
    only_diffs : bool
        Return only differences in timestamp values (the default is True).

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy.core import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID-RAW&#39;,
    &gt;&gt;&gt;                     &#39;Some.Fully.Qualified.Cwms.Ts.ID-REV&#39;]
    &gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
    &gt;&gt;&gt; df.head()

                        Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                        value       quality_code    value   quality_code
        date_time                           
        1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
        1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
        1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
        1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
        1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
    ```
    &#34;&#34;&#34;
    df_list = []
    for idx, p_cwms_ts_id in enumerate(p_cwms_ts_id_list):
        if p_units_list:
            p_units = p_units_list[idx]
        else:
            p_units = None
        df = self.get_por(
            p_cwms_ts_id,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=p_trim,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            return_df=True,
            local_tz=local_tz,
        )
        df.set_index(&#34;date_time&#34;, inplace=True)
        df_list.append(df)

    # reference: https://stackoverflow.com/a/47112033/4296857
    comp = pd.concat(df_list, axis=&#34;columns&#34;, keys=p_cwms_ts_id_list)
    if only_diffs:
        df_list = []
        # np.isclose only accepts 2 arrays, getting a combination of all
        # possible arrays to compare
        comb = combinations(p_cwms_ts_id_list, 2)
        for i in comb:
            a, b = i
            bol = pd.DataFrame(
                np.isclose(comp[a][&#34;value&#34;].values, comp[b][&#34;value&#34;].values)
                == False
            )
            df_list.append(bol)
        bol = pd.concat(df_list, axis=1).apply(
            lambda row: True in row.values, axis=1
        )
        comp = comp[bol.values]
    return comp</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_by_df"><code class="name flex">
<span>def <span class="ident">delete_by_df</span></span>(<span>self, df, p_override_protection='F', p_version_date=None, p_db_office_code=26)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes time series data with a pandas.Core.DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.core.DataFrame</code></dt>
<dd>A pandas data frame with columns <code>ts_id</code> and <code>date_time</code>.</dd>
<dt><strong><code>p_override_protection</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>type</code></dt>
<dd>The version date of the data.</dd>
<dt><strong><code>p_db_office_code</code></strong> :&ensp;<code>type</code></dt>
<dd>The unique numeric code that identifies the office that owns the time series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>True for success</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; df = cwms.retrieve_ts("Some.Fully.Qualified.Cwms.pathname","2019/1/1","2019/9/1","cms",return_df=True)
&gt;&gt;&gt; df["ts_id"] = "Some.Fully.Qualified.Cwms.pathname"
&gt;&gt;&gt; cwms.delete_by_df(df)
    True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def delete_by_df(
    self, df, p_override_protection=&#34;F&#34;, p_version_date=None, p_db_office_code=26
):
    &#34;&#34;&#34;Deletes time series data with a pandas.Core.DataFrame.

    Parameters
    ----------
    df : pandas.core.DataFrame
        A pandas data frame with columns `ts_id` and `date_time`.
    p_override_protection : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : type
        The version date of the data.
    p_db_office_code : type
        The unique numeric code that identifies the office that owns the time series.

    Returns
    -------
    boolean
        True for success
    Examples
    -------
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; df = cwms.retrieve_ts(&#34;Some.Fully.Qualified.Cwms.pathname&#34;,&#34;2019/1/1&#34;,&#34;2019/9/1&#34;,&#34;cms&#34;,return_df=True)
    &gt;&gt;&gt; df[&#34;ts_id&#34;] = &#34;Some.Fully.Qualified.Cwms.pathname&#34;
    &gt;&gt;&gt; cwms.delete_by_df(df)
        True
    &#34;&#34;&#34;
    # A standard format between the database and script
    alter_session_sql = (
        &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
    )

    cur = self.conn.cursor()
    cur.execute(alter_session_sql)
    s = &#34;to_date(&#39;{}&#39;)&#34;
    df = df.copy()
    df[&#34;string_date_time&#34;] = [
        s.format(x.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)) for x in df[&#34;date_time&#34;]
    ]
    delete_sql = &#34;&#34;&#34;
                delete from cwms_20.at_tsv_{}
                where ts_code = {}
                and date_time in {}
                &#34;&#34;&#34;
    if not p_override_protection:
        delete_sql += &#34;&#34;&#34;
                and  quality_code not in (select quality_code from
                cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                &#34;&#34;&#34;
    df.set_index(&#34;date_time&#34;, inplace=True)

    grouped = df.groupby(&#34;ts_id&#34;)

    # if any ts_id or year fails, all deletes will be rolled back
    try:

        for p_cwms_ts_id, value in grouped:
            grpd = value.groupby(pd.Grouper(freq=&#34;Y&#34;))

            # Get the ts_code by id because the at_tsv_YEAR tbls do not have
            # ts_ids
            ts_code = self.get_ts_code(
                p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
            )

            # Group by year to go through all of the at_tsv_YEAR tbls
            for date, val in grpd:
                value_len = str(val.shape[0])
                year = str(date.year)
                logger.info(
                    f&#34;Deleting {value_len} values from {p_cwms_ts_id} at table {year}&#34;
                )
                times = &#34;(&#34;
                for time in list(val[&#34;string_date_time&#34;].values)[:-1]:
                    times += time + (&#34;,&#34;)
                times += list(val[&#34;string_date_time&#34;].values)[-1] + &#34;)&#34;

                sql = delete_sql.format(year, ts_code, times)

                if p_version_date:
                    sql += &#34;and version_date = to_date(&#39;{}&#39;)&#34;.format(p_version_date)

                cur.execute(sql)

    except Exception as e:
        logger.error(e)
        cur.execute(&#34;rollback&#34;)
        cur.close()
        raise Exception(e.__str__())
    cur.execute(&#34;commit&#34;)
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_ts"><code class="name flex">
<span>def <span class="ident">delete_ts</span></span>(<span>self, p_cwms_ts_id, p_delete_action='DELETE TS ID', p_db_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a time series from the database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the time series to delete.</dd>
<dt><strong><code>p_delete_action</code></strong> :&ensp;<code>type</code></dt>
<dd>Specifies what to delete.</dd>
<dt><strong><code>p_db_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office will be used..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; cwms.delete_ts(&quot;Some.Fully.Qualified.Cwms.Ts.Id&quot;,
                    &quot;DELETE TS DATA&quot;)
    True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def delete_ts(
    self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
):
    &#34;&#34;&#34;Deletes a time series from the database.

    Parameters
    ----------
    p_cwms_ts_id : str
        The identifier of the time series to delete.
    p_delete_action : type
        Specifies what to delete.
    p_db_office_id : type
        The office that owns the time series. If not specified or NULL,
        the session user&#39;s default office will be used..

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                        &#34;DELETE TS DATA&#34;)
        True
    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:

        cur.callproc(
            &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
        )
    except DatabaseError as e:
        logger.error(e)
        cur.close()
        raise DatabaseError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_ts_window"><code class="name flex">
<span>def <span class="ident">delete_ts_window</span></span>(<span>self, p_cwms_ts_id, start_time, end_time, p_override_protection='F', p_version_date=None, p_db_office_code=26)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete ts with user specified start and end date.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The start time of the time window.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The end time of the time window.</dd>
<dt><strong><code>p_override_protection</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>The version date of the data</dd>
<dt><strong><code>p_db_office_code</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>The unique numeric code identifying the office owning the time
series (the default is 26).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; start_time = '2018/1/1'
&gt;&gt;&gt; end_time = '2019/2/1'
&gt;&gt;&gt; p_cwms_ts_id = 'your.cwms.ts.id'
&gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
&gt;&gt;&gt;                      p_override_protection='F', p_version_date=None,
&gt;&gt;&gt;                      p_db_office_code=26)
    True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def delete_ts_window(
    self,
    p_cwms_ts_id,
    start_time,
    end_time,
    p_override_protection=&#34;F&#34;,
    p_version_date=None,
    p_db_office_code=26,
):
    &#34;&#34;&#34;Delete ts with user specified start and end date.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    start_time : str &#34;%Y/%m/%d&#34;
        The start time of the time window.
    end_time : str &#34;%Y/%m/%d&#34;
        The end time of the time window.
    p_override_protection : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        The version date of the data
    p_db_office_code : int
       The unique numeric code identifying the office owning the time
       series (the default is 26).

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; start_time = &#39;2018/1/1&#39;
    &gt;&gt;&gt; end_time = &#39;2019/2/1&#39;
    &gt;&gt;&gt; p_cwms_ts_id = &#39;your.cwms.ts.id&#39;
    &gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
    &gt;&gt;&gt;                      p_override_protection=&#39;F&#39;, p_version_date=None,
    &gt;&gt;&gt;                      p_db_office_code=26)
        True
    ```
    &#34;&#34;&#34;

    p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
    p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

    alter_session_sql = (
        &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
    )
    cur = self.conn.cursor()
    cur.execute(alter_session_sql)

    delete_sql = &#34;&#34;&#34;
                delete from cwms_20.at_tsv_{}
                where ts_code = {}
                and date_time between to_date(&#39;{}&#39;) and to_date(&#39;{}&#39;)
                &#34;&#34;&#34;
    if not p_override_protection:
        delete_sql += &#34;&#34;&#34;
                and  quality_code not in (select quality_code from
                cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                &#34;&#34;&#34;

    ts_code = self.get_ts_code(
        p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
    )

    try:
        for year in range(p_start_time.year, (p_end_time.year + 1)):
            table = str(year)
            logger.info(f&#34;Deleteing {p_cwms_ts_id} from table {table}&#34;)
            sql = delete_sql.format(table, ts_code, start_time, end_time)
            if p_version_date:
                sql += f&#34;and version_date = to_date(&#39;{p_version_date}&#39;)&#34;
            cur.execute(sql)
    except Exception as e:
        logger.error(e)
        cur.execute(&#34;rollback&#34;)
        cur.close()
        raise Exception(e.__str__())
    cur.execute(&#34;commit&#34;)
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_extents"><code class="name flex">
<span>def <span class="ident">get_extents</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the earliest and latest non-null time series data date in
the database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The earliest and latest non-null dates in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; cwms.get_extents('Some.Fully.Qualified.Cwms.Ts.ID')
    (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def get_extents(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
        the database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : int
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The earliest and latest non-null dates in the time series

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; cwms.get_extents(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
    ```
    &#34;&#34;&#34;

    min_date = self.get_ts_min_date(
        p_cwms_ts_id,
        p_time_zone=p_time_zone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    max_date = self.get_ts_max_date(
        p_cwms_ts_id,
        p_time_zone=p_time_zone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    return min_date, max_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_por"><code class="name flex">
<span>def <span class="ident">get_por</span></span>(<span>self, p_cwms_ts_id, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, return_df=True, local_tz=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Short summary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_trim</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to trim missing values
from the beginning and end of the retrieved values.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.core.frame.DataFrame</code> or <code>list</code></dt>
<dd>The period of record for given time series identifier</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="Python">&gt;&gt;&gt; from cwmspy.core import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; df = cwms.get_por('Some.Fully.Qualified.Cwms.Ts.ID')
&gt;&gt;&gt; df.head()
                date_time        value  quality_code
    0 1975-02-18 08:00:00   750.396435             3
    1 1975-02-19 08:00:00   750.396435             3
    2 1975-02-20 08:00:00  1403.666086             3
    3 1975-02-21 08:00:00  1613.210750             0
    4 1975-02-22 08:00:00  1765.272217             0
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def get_por(
    self,
    p_cwms_ts_id,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    return_df=True,
    local_tz=False,
):
    &#34;&#34;&#34;Short summary.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.

    Returns
    -------
    pd.core.frame.DataFrame or list
        The period of record for given time series identifier

    Examples
    -------
    ```Python
    &gt;&gt;&gt; from cwmspy.core import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; df = cwms.get_por(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
    &gt;&gt;&gt; df.head()
                    date_time        value  quality_code
        0 1975-02-18 08:00:00   750.396435             3
        1 1975-02-19 08:00:00   750.396435             3
        2 1975-02-20 08:00:00  1403.666086             3
        3 1975-02-21 08:00:00  1613.210750             0
        4 1975-02-22 08:00:00  1765.272217             0
    ```

    &#34;&#34;&#34;

    mn, mx = self.get_extents(
        p_cwms_ts_id=p_cwms_ts_id,
        p_time_zone=p_timezone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    # To get a little overlap
    mn = mn - datetime.timedelta(days=1)
    mx = mx + datetime.timedelta(days=1)

    start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
    end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

    por = self.retrieve_ts(
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=p_units,
        p_timezone=p_timezone,
        p_trim=&#34;F&#34;,
        p_start_inclusive=p_start_inclusive,
        p_end_inclusive=p_end_inclusive,
        p_previous=p_previous,
        p_next=p_next,
        version_date=version_date,
        p_max_version=p_max_version,
        p_office_id=p_office_id,
        return_df=return_df,
        local_tz=local_tz,
    )

    return por</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_code"><code class="name flex">
<span>def <span class="ident">get_ts_code</span></span>(<span>self, p_cwms_ts_id, p_db_office_code=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the CWMS TS Code of a given pathname.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>CWMS time series identifier.</dd>
<dt><strong><code>p_db_office_code</code></strong> :&ensp;<code>int</code></dt>
<dd>The unique numeric code identifying the office
owning the time series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the unique numeric code value for the specified
time series if successful, False otherwise.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; cwms.get_ts_code(&quot;Some.fully.qualified.ts.id&quot;)
    &quot;04319021&quot;

</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
    &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.

    Parameters
    ----------
    p_cwms_ts_id : str
        CWMS time series identifier.
    p_db_office_code : int
        The unique numeric code identifying the office
                           owning the time series

    Returns
    -------
    str
        the unique numeric code value for the specified
            time series if successful, False otherwise.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; cwms.get_ts_code(&#34;Some.fully.qualified.ts.id&#34;)
        &#34;04319021&#34;

    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:

        ts_code = cur.callfunc(
            &#34;cwms_ts.get_ts_code&#34;,
            cx_Oracle.STRING,
            [p_cwms_ts_id, p_db_office_code],
        )
    except DatabaseError as e:
        logger.error(e)
        cur.close()
        raise ValueError(e.__str__())
    logger.info(f&#34;get_ts_code returned {ts_code}&#34;)
    cur.close()

    return ts_code</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date"><code class="name flex">
<span>def <span class="ident">get_ts_max_date</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the latest non-null time series data date in the
database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The latest non-null date in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.get_ts_max_date('Some.Fully.Qualified.Cwms.Ts.ID')
    datetime.datetime(2019, 8, 16, 7, 0)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def get_ts_max_date(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
        database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : type
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The latest non-null date in the time series

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.get_ts_max_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        datetime.datetime(2019, 8, 16, 7, 0)
    ```
    &#34;&#34;&#34;
    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    cur = self.conn.cursor()
    try:

        max_date = cur.callfunc(
            &#34;cwms_ts.get_ts_max_date&#34;,
            cx_Oracle.DATETIME,
            [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
        )
    except DatabaseError as e:
        cur.close()
        logger.error(e)
        raise ValueError(e.__str__())
    logger.info(f&#34;max_date returned {max_date}&#34;)
    cur.close()

    return max_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date"><code class="name flex">
<span>def <span class="ident">get_ts_min_date</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the earliest non-null time series data date in the
database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The earliest non-null date in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import CWMS

&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; cwms.get_ts_min_date('Some.Fully.Qualified.Cwms.Ts.ID')

    datetime.datetime(1975, 2, 18, 8, 0)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def get_ts_min_date(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
        database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : type
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The earliest non-null date in the time series

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS

    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; cwms.get_ts_min_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)

        datetime.datetime(1975, 2, 18, 8, 0)
    ```
    &#34;&#34;&#34;

    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    cur = self.conn.cursor()
    try:

        min_date = cur.callfunc(
            &#34;cwms_ts.get_ts_min_date&#34;,
            cx_Oracle.DATETIME,
            [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
        )
    except DatabaseError as e:
        logger.error(e)
        cur.close()
        raise ValueError(e.__str__())
    logger.info(f&#34;get_ts_min_date returned {min_date}&#34;)
    cur.close()

    return min_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.rename_ts"><code class="name flex">
<span>def <span class="ident">rename_ts</span></span>(<span>self, p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new=None, p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Renames a time series in the database, optionally setting a new
regular interval offset.</p>
<pre><code>Restrictions on changing include:
- New time series identifier must agree with new/existing data
    interval and offset (regular/irregular)
- Cannot change time utc offset if from one regular offset to
    another if time series data exists
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_old</code></strong> :&ensp;<code>str</code></dt>
<dd>The existing time series identifier.</dd>
<dt><strong><code>p_cwms_ts_id_new</code></strong> :&ensp;<code>str</code></dt>
<dd>The new time series identifier.</dd>
<dt><strong><code>p_utc_offset_new</code></strong> :&ensp;<code>int</code></dt>
<dd>The new offset into the utc data interval in minutes.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; p_cwms_ts_id_old = &quot;Some.Fully.Qualified.Ts.ID&quot;
&gt;&gt;&gt; p_cwms_ts_id_new = &quot;New.Fully.Qualified.Ts.ID&quot;
&gt;&gt;&gt; cwms.rename_ts(
    p_cwms_ts_id_old,
    p_cwms_ts_id_new,
    p_utc_offset_new=None,
    p_office_id=None
    )
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def rename_ts(
    self,
    p_cwms_ts_id_old,
    p_cwms_ts_id_new,
    p_utc_offset_new=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
        regular interval offset.

        Restrictions on changing include:
        - New time series identifier must agree with new/existing data
            interval and offset (regular/irregular)
        - Cannot change time utc offset if from one regular offset to
            another if time series data exists

    Parameters
    ----------
    p_cwms_ts_id_old : str
        The existing time series identifier.
    p_cwms_ts_id_new : str
        The new time series identifier.
    p_utc_offset_new : int
        The new offset into the utc data interval in minutes.
    p_office_id : str
        The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office is used.

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; p_cwms_ts_id_old = &#34;Some.Fully.Qualified.Ts.ID&#34;
    &gt;&gt;&gt; p_cwms_ts_id_new = &#34;New.Fully.Qualified.Ts.ID&#34;
    &gt;&gt;&gt; cwms.rename_ts(
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None
        )
    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:

        cur.callproc(
            &#34;cwms_ts.rename_ts&#34;,
            [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
        )
    except DatabaseError as e:
        logger.error(e)
        cur.close()
        raise DatabaseError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_multi_ts"><code class="name flex">
<span>def <span class="ident">retrieve_multi_ts</span></span>(<span>self, p_cwms_ts_id_list, start_time=None, end_time=None, p_units_list=None, p_timezone='UTC', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, return_df=True, local_tz=False, por=False, pivot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves time series data for a list of specified time series
and time window or period of record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of time series identifiers.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The start of the time window in the specified or default time zone.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The end of the time window in the specified or default time zone.</dd>
<dt><strong><code>p_units_list</code></strong> :&ensp;<code>list</code></dt>
<dd>Unit list to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
<dt><strong><code>por</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return period of record.</dd>
<dt><strong><code>pivot</code></strong> :&ensp;<code>bool</code></dt>
<dd>Pivot dataframe so cwms ts id's are columns.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas</code> <code>df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy.core import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; p_cwms_ts_id_list = ['Some.Fully.Qualified.Cwms.Ts.ID',
&gt;&gt;&gt;                     'Second.Fully.Qualified.Cwms.Ts.ID']
&gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, '2019/1/1', '2019/9/1')
&gt;&gt;&gt; df.head()

                date_time                                ts_id       value  quality_code
    0 2018-12-31 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      574.831986             0
    1 2019-01-01 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      668.277580             0
    2 2019-01-02 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      608.812202             0
    3 2019-01-03 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      597.485463             0
    4 2019-01-04 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      560.673563             0
</code></pre>
<pre><code class="python">&gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
&gt;&gt;&gt;                            '2019/1/1',
&gt;&gt;&gt;                            '2019/9/1',
&gt;&gt;&gt;                            pivot=True)
&gt;&gt;&gt; df.head()

    ts_id                  'Some.Fully.Qualified.Cwms.Ts.ID'      'Second.Fully.Qualified.Cwms.Ts.ID'
    date_time
    2018-12-31 08:00:00                           574.831986                                     NaN
    2018-12-31 23:00:00                                  NaN                                     0.0
    2019-01-01 00:00:00                                  NaN                                     0.0
    2019-01-01 01:00:00                                  NaN                                     0.0
    2019-01-01 02:00:00                                  NaN                                     0.0
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def retrieve_multi_ts(
    self,
    p_cwms_ts_id_list,
    start_time=None,
    end_time=None,
    p_units_list=None,
    p_timezone=&#34;UTC&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    return_df=True,
    local_tz=False,
    por=False,
    pivot=False,
):

    &#34;&#34;&#34;
    Retrieves time series data for a list of specified time series
        and time window or period of record.

    Parameters
    ----------
    p_cwms_ts_id_list : list
        List of time series identifiers.
    start_time : str
        The start of the time window in the specified or default time zone.
    end_time : str
        The end of the time window in the specified or default time zone.
    p_units_list : list
        Unit list to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.
    por : bool
        Return period of record.
    pivot : bool
        Pivot dataframe so cwms ts id&#39;s are columns.

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy.core import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;,
    &gt;&gt;&gt;                     &#39;Second.Fully.Qualified.Cwms.Ts.ID&#39;]
    &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, &#39;2019/1/1&#39;, &#39;2019/9/1&#39;)
    &gt;&gt;&gt; df.head()

                    date_time                                ts_id       value  quality_code
        0 2018-12-31 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      574.831986             0
        1 2019-01-01 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      668.277580             0
        2 2019-01-02 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      608.812202             0
        3 2019-01-03 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      597.485463             0
        4 2019-01-04 08:00:00  Some.Fully.Qualified.Cwms.Ts.ID      560.673563             0
    ```
    ```python
    &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
    &gt;&gt;&gt;                            &#39;2019/1/1&#39;,
    &gt;&gt;&gt;                            &#39;2019/9/1&#39;,
    &gt;&gt;&gt;                            pivot=True)
    &gt;&gt;&gt; df.head()

        ts_id                  &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;      &#39;Second.Fully.Qualified.Cwms.Ts.ID&#39;
        date_time
        2018-12-31 08:00:00                           574.831986                                     NaN
        2018-12-31 23:00:00                                  NaN                                     0.0
        2019-01-01 00:00:00                                  NaN                                     0.0
        2019-01-01 01:00:00                                  NaN                                     0.0
        2019-01-01 02:00:00                                  NaN                                     0.0
    ```
    &#34;&#34;&#34;

    l = []
    for i, ts_id in enumerate(p_cwms_ts_id_list):
        if p_units_list:
            p_units = p_units_list[i]
        else:
            p_units = None

        arg = [
            p_units,
            p_timezone,
            &#34;F&#34;,
            p_start_inclusive,
            p_end_inclusive,
            p_previous,
            p_next,
            version_date,
            p_max_version,
            p_office_id,
            return_df,
            local_tz,
        ]

        if por:
            args0 = [ts_id]
            args = args0 + arg
            rslt = self.get_por(*args)
        else:
            args0 = [ts_id, start_time, end_time]
            args = args0 + arg
            rslt = self.retrieve_ts(*args)

        if return_df:
            rslt[&#34;ts_id&#34;] = ts_id

        l.append(rslt)

    if return_df:
        l = pd.concat(l, ignore_index=True)
        l = l[[&#34;date_time&#34;, &#34;ts_id&#34;, &#34;value&#34;, &#34;quality_code&#34;]]
        if pivot:
            l = l.pivot(index=&#34;date_time&#34;, columns=&#34;ts_id&#34;, values=&#34;value&#34;)

    return l</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts"><code class="name flex">
<span>def <span class="ident">retrieve_ts</span></span>(<span>self, p_cwms_ts_id, start_time, end_time, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, return_df=True, local_tz=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves time series data for a specified time series and
time window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier to retrieve data for.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The start time of the time window.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The end time of the time window.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_trim</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to trim missing values
from the beginning and end of the retrieved values.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas</code> <code>df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id='Some.Fully.Qualified.Ts.Id',
                        start_time='2019/1/1', end_time='2019/9/1', return_df=True)
&gt;&gt;&gt; df.head()
                date_time       value  quality_code
    0 2018-12-31 08:00:00  574.831986             0
    1 2019-01-01 08:00:00  668.277580             0
    2 2019-01-02 08:00:00  608.812202             0
    3 2019-01-03 08:00:00  597.485463             0
    4 2019-01-04 08:00:00  560.673563             0
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def retrieve_ts(
    self,
    p_cwms_ts_id,
    start_time,
    end_time,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    return_df=True,
    local_tz=False,
):
    &#34;&#34;&#34;Retrieves time series data for a specified time series and
        time window.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier to retrieve data for.
    start_time : str &#34;%Y/%m/%d&#34;
        The start time of the time window.
    end_time : str &#34;%Y/%m/%d&#34;
        The end time of the time window.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.


    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                            start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
    &gt;&gt;&gt; df.head()
                    date_time       value  quality_code
        0 2018-12-31 08:00:00  574.831986             0
        1 2019-01-01 08:00:00  668.277580             0
        2 2019-01-02 08:00:00  608.812202             0
        3 2019-01-03 08:00:00  597.485463             0
        4 2019-01-04 08:00:00  560.673563             0
    ```
    &#34;&#34;&#34;

    p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
    p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)

    cur = self.conn.cursor()
    p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
    try:

        cur.callproc(
            &#34;cwms_ts.retrieve_ts&#34;,
            [
                p_at_tsv_rc,
                p_cwms_ts_id,
                p_units,
                p_start_time,
                p_end_time,
                p_timezone,
                p_trim,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                p_version_date,
                p_max_version,
                p_office_id,
            ],
        )

    except DatabaseError as e:
        logger.error(e)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()

    output = [r for r in p_at_tsv_rc.getvalue()]
    output_len = len(output)
    logger.info(f&#34;Found {output_len} records.&#34;)
    if local_tz:
        for i, v in enumerate(output):
            date = v[0]
            local = self._convert_to_local_time(date=date, timezone=p_timezone)

            output[i] = [local] + [x for x in v[1:]]

    if return_df:
        output = pd.DataFrame(
            output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        )

    return output</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.store_by_df"><code class="name flex">
<span>def <span class="ident">store_by_df</span></span>(<span>self, df, p_store_rule='REPLACE ALL', p_override_prot='F', version_date=None, p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Stores time series data to the database with pandas.core.dataframe as input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.core.DataFrame</code></dt>
<dd>Pandas DataFrame that requires <code>ts_id</code>, <code>date_time</code>, <code>units</code>,
and <code>value</code> columns.
If optional column <code>quality_code</code> does not exist,
all quality codes are assumed equal to 0.</dd>
<dt><strong><code>p_store_rule</code></strong> :&ensp;<code>type</code></dt>
<dd>The store rule to use.</dd>
<dt><strong><code>p_override_prot</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Description of parameter <code>p_office_id</code>.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office owning the time series. If not specified or NULL, the
session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd><code>True</code> for success</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; p_cwms_ts_id = 'Some.Fully.Qualified.Pathname'
&gt;&gt;&gt; p_units = 'cms'
&gt;&gt;&gt; start_time = '2019/1/1'
&gt;&gt;&gt; end_time = '2019/8/1'
&gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
&gt;&gt;&gt;                     start_time=start_time,
&gt;&gt;&gt;                     end_time=end_time,
&gt;&gt;&gt;                     p_units=p_units
&gt;&gt;&gt;                     )
&gt;&gt;&gt; df['units'] = p_units
&gt;&gt;&gt; df['ts_id'] = p_cwms_ts_id
&gt;&gt;&gt; df['value'] = df['value'] / 1.1
&gt;&gt;&gt; cwms.store_by_df(df)
    True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def store_by_df(
    self,
    df,
    p_store_rule=&#34;REPLACE ALL&#34;,
    p_override_prot=&#34;F&#34;,
    version_date=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Stores time series data to the database with pandas.core.dataframe as input.

    Parameters
    ----------
    df : pandas.core.DataFrame
        Pandas DataFrame that requires `ts_id`, `date_time`, `units`,
        and `value` columns.  If optional column `quality_code` does not exist,
        all quality codes are assumed equal to 0.
    p_store_rule : type
        The store rule to use.
    p_override_prot : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        Description of parameter `p_office_id`.
    p_office_id : type
        The office owning the time series. If not specified or NULL, the
        session user&#39;s default office is used.

    Returns
    -------
    Boolean
        `True` for success

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
    &gt;&gt;&gt; p_units = &#39;cms&#39;
    &gt;&gt;&gt; start_time = &#39;2019/1/1&#39;
    &gt;&gt;&gt; end_time = &#39;2019/8/1&#39;
    &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
    &gt;&gt;&gt;                     start_time=start_time,
    &gt;&gt;&gt;                     end_time=end_time,
    &gt;&gt;&gt;                     p_units=p_units
    &gt;&gt;&gt;                     )
    &gt;&gt;&gt; df[&#39;units&#39;] = p_units
    &gt;&gt;&gt; df[&#39;ts_id&#39;] = p_cwms_ts_id
    &gt;&gt;&gt; df[&#39;value&#39;] = df[&#39;value&#39;] / 1.1
    &gt;&gt;&gt; cwms.store_by_df(df)
        True
    ```

    &#34;&#34;&#34;

    if &#34;quality_code&#34; not in df.columns:
        df[&#34;quality_code&#34;] = 0

    grouped = df.groupby(&#34;ts_id&#34;)

    for p_cwms_ts_id, value in grouped:

        grpd = value.groupby(&#34;units&#34;)

        for p_units, val in grpd:
            # Only want to write new data to disk
            # Get current data, merge it for comparison

            # Add a little overlap to get current data
            min_date = (
                val[&#34;date_time&#34;].min() - datetime.timedelta(days=1)
            ).strftime(&#34;%Y/%m/%d&#34;)
            max_date = (
                val[&#34;date_time&#34;].max() + datetime.timedelta(days=1)
            ).strftime(&#34;%Y/%m/%d&#34;)

            # Will throw an error if time series identifier does not exist
            try:
                logger.info(&#34;Get existing data if it does exist for comparison&#34;)
                current_data = self.retrieve_ts(
                    p_cwms_ts_id=p_cwms_ts_id,
                    start_time=min_date,
                    end_time=max_date,
                    p_units=p_units,
                )
                logger.info(&#34;Merging with existing data to only write new values&#34;)
                merged = val.merge(
                    current_data,
                    on=[&#34;date_time&#34;, &#34;value&#34;],
                    how=&#34;outer&#34;,
                    suffixes=[&#34;&#34;, &#34;_&#34;],
                    indicator=True,
                )

                # The data to store after comparing to current data
                new_data = merged[merged[&#34;_merge&#34;] == &#34;left_only&#34;]
                new_data_len = new_data.shape[0]
                logger.info(f&#34;Loading {new_data_len} new values&#34;)
            except ValueError:
                new_data = val.copy()
            self.store_ts(
                p_cwms_ts_id=p_cwms_ts_id,
                p_units=p_units,
                times=list(new_data[&#34;date_time&#34;]),
                values=list(new_data[&#34;value&#34;]),
                qualities=list(new_data[&#34;quality_code&#34;]),
                format=None,
                p_store_rule=p_store_rule,
                p_override_prot=p_override_prot,
                version_date=version_date,
                p_office_id=p_office_id,
            )
        return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.store_ts"><code class="name flex">
<span>def <span class="ident">store_ts</span></span>(<span>self, p_cwms_ts_id, p_units, times, values, qualities=None, format=None, p_store_rule='REPLACE ALL', p_override_prot='F', version_date=None, p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Stores time series data to the database using parameter types
compatible with cx_Oracle Pyton package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit of the data values.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>list</code></dt>
<dd>The UTC times of the data values.
Can be string or type datetime</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>The data values.</dd>
<dt><strong><code>p_qualities</code></strong> :&ensp;<code>list</code></dt>
<dd>The data quality codes for the data values.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
parse all the way up to nanoseconds. See strftime documentation
for more information on choices:
<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</a>
store_ts will try to infer format if None.</dd>
<dt><strong><code>p_store_rule</code></strong> :&ensp;<code>type</code></dt>
<dd>The store rule to use.</dd>
<dt><strong><code>p_override_prot</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Description of parameter <code>p_office_id</code>.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office owning the time series. If not specified or NULL, the
session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; p_cwms_ts_id = 'Some.Fully.Qualified.Cwms.Ts.ID'
&gt;&gt;&gt; p_units = &quot;cms&quot;
&gt;&gt;&gt; values = [1,2,3]
&gt;&gt;&gt; p_qualities = [0,0,0]
&gt;&gt;&gt; times = ['2019/1/1','2019/1/2','2019/1/3']
&gt;&gt;&gt; times = [datetime.datetime.strptime(x, &quot;%Y/%m/%d&quot;) for x in times]
&gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
    True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def store_ts(
    self,
    p_cwms_ts_id,
    p_units,
    times,
    values,
    qualities=None,
    format=None,
    p_store_rule=&#34;REPLACE ALL&#34;,
    p_override_prot=&#34;F&#34;,
    version_date=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Stores time series data to the database using parameter types
        compatible with cx_Oracle Pyton package.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_units : str
        The unit of the data values.
    times : list
        The UTC times of the data values.  Can be string or type datetime
    values : list
        The data values.
    p_qualities : list
        The data quality codes for the data values.
    format : str
        strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
        parse all the way up to nanoseconds. See strftime documentation
        for more information on choices:
            https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
        store_ts will try to infer format if None.
    p_store_rule : type
        The store rule to use.
    p_override_prot : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        Description of parameter `p_office_id`.
    p_office_id : type
        The office owning the time series. If not specified or NULL, the
        session user&#39;s default office is used.

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;
    &gt;&gt;&gt; p_units = &#34;cms&#34;
    &gt;&gt;&gt; values = [1,2,3]
    &gt;&gt;&gt; p_qualities = [0,0,0]
    &gt;&gt;&gt; times = [&#39;2019/1/1&#39;,&#39;2019/1/2&#39;,&#39;2019/1/3&#39;]
    &gt;&gt;&gt; times = [datetime.datetime.strptime(x, &#34;%Y/%m/%d&#34;) for x in times]
    &gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
        True
    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()

    p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

    t = pd.to_datetime(times, utc=True, infer_datetime_format=True, format=format)
    # Get the UTC times of the data values in Java milliseconds
    # this is what actually goes into Store_Ts
    zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
    p_times = [((time - zero).total_seconds() * 1000) for time in t]

    if not version_date:
        p_version_date = datetime.datetime(1111, 11, 11)
    else:
        p_version_date = version_date
    if not qualities:
        p_qualities = [0 for x in p_times]
    else:
        p_qualities = qualities

    try:

        cur.callproc(
            &#34;cwms_ts.store_ts&#34;,
            [
                p_cwms_ts_id,
                p_units,
                p_times,
                p_values,
                p_qualities,
                p_store_rule,
                p_override_prot,
                p_version_date,
                p_office_id,
            ],
        )
    except DatabaseError as e:
        logger.error(e)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cwmspy" href="index.html">cwmspy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cwmspy.cwms_ts.CwmsTsMixin" href="#cwmspy.cwms_ts.CwmsTsMixin">CwmsTsMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.compare_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.compare_ts">compare_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_by_df" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_by_df">delete_by_df</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_ts">delete_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_ts_window" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_ts_window">delete_ts_window</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_extents" href="#cwmspy.cwms_ts.CwmsTsMixin.get_extents">get_extents</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_por" href="#cwmspy.cwms_ts.CwmsTsMixin.get_por">get_por</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_code" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_code">get_ts_code</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date">get_ts_max_date</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date">get_ts_min_date</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.rename_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.rename_ts">rename_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_multi_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_multi_ts">retrieve_multi_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts">retrieve_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.store_by_df" href="#cwmspy.cwms_ts.CwmsTsMixin.store_by_df">store_by_df</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.store_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.store_ts">store_ts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>