<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>cwmspy.cwms_level API documentation</title>
<meta name="description" content="Facilities for working with location levels." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cwmspy.cwms_level</code></h1>
</header>
<section id="section-intro">
<p>Facilities for working with location levels.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Facilities for working with location levels.
&#34;&#34;&#34;
import datetime
from datetime import timedelta
import cx_Oracle
from cx_Oracle import DatabaseError
import inspect
import pandas as pd
import logging
import sys

from .utils import log_decorator


logger = logging.getLogger(__name__)
ld = log_decorator(logger)


class CwmsLevelMixin:
    @ld
    def retrieve_location_level_values(
        self,
        p_location_level_id,
        p_start_time,
        p_end_time,
        p_level_units,
        p_timezone_id=&#34;GMT&#34;,
        p_office_id=&#34;NWDP&#34;,
        df=True,
    ):
        &#34;&#34;&#34;
        
        Retrieves a time series of location level values for a specified location level and a time window.

        Parameters
        ----------
        p_location_level_id : str
            The location level identifier. Format is location.parameter.parameter_type.duration.specified_level
        p_start_time : str 
            The start of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_end_time : str
            The end of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_level_units : str
            The value unit to retrieve the level values in
        p_timezone_id : str
            The time zone of the time window. Retrieved dates are also in this time zone (the default is &#34;GMT&#34;).
        p_office_id : str
            The office that owns the location level. If not specified or NULL, the session user&#39;s default office is used` (the default is &#34;NWDP&#34;).
        df : boolean
            Return a pandas.Core.DataFrame (the default is True).

        Returns
        -------
        type: either list or pandas.Core.DataFrame
        The location level values. The time series contains values at the spcified start and end times of the time window and may contain values at intermediate times
            * If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero
            * If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero
            * If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero
        The quality code of each returned value will be one of the following
            * 0: The value for all times between the previous value time and this one is the same as the previous value
            * 1: The value for all times between the previous value time and this one is interpolated between the previous value and this one
                
        
        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_level_units = &#39;cms&#39;
        &gt;&gt;&gt; p_start_time = &#39;01/01/2000&#39;
        &gt;&gt;&gt; p_end_time = &#39;05/01/2000&#39;
        &gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_cwms_ts_id=p_cwms_ts_id,
        &gt;&gt;&gt;                     p_start_time=p_start_time,
        &gt;&gt;&gt;                     p_end_time=p_end_time,
        &gt;&gt;&gt;                     p_level_units=p_level_units
        &gt;&gt;&gt;                     )
        ```

        &#34;&#34;&#34;

        try:
            cur = self.conn.cursor()

            bind_vars = {
                &#34;p_location_level_id&#34;: p_location_level_id,
                &#34;p_level_units&#34;: p_level_units,
                &#34;p_start_time&#34;: p_start_time,
                &#34;p_end_time&#34;: p_end_time,
                &#34;p_timezone_id&#34;: p_timezone_id,
                &#34;p_office_id&#34;: p_office_id,
            }

            logger.info(&#34;Start retrieve_location_level_values.&#34;)
            cur.execute(
                &#34;&#34;&#34;
                select * from table( cwms_level.retrieve_location_level_values(
                p_location_level_id =&gt;:p_location_level_id,
                p_level_units       =&gt;:p_level_units,
                p_start_time        =&gt;to_date( :p_start_time, &#39;dd-mm-yyyy hh24mi&#39; ),
                p_end_time          =&gt;to_date( :p_end_time, &#39;dd-mm-yyyy hh24mi&#39; ),
                p_timezone_id       =&gt;:p_timezone_id,
                p_office_id         =&gt;:p_office_id ) )&#34;&#34;&#34;,
                bind_vars,
            )
            records = cur.fetchall()
            cur.close()
        except Exception as e:
            logger.error(e)
            cur.close()
            # print bind_vars
            raise DatabaseError(e.__str__())
        result = []
        # The following code deals with the hacky location level API call that HEC
        # Implemented. The quality flag is an interpolation flag, meaning 0 is not
        # to be interopolated.
        lastVal = None
        for row in records:
            if row[2] == 0 and lastVal != None:
                result.append([row[0] - timedelta(minutes=1), lastVal, row[2]])
            result.append(row)
            lastVal = row[1]
        records = str(len(result))
        logger.info(f&#34;Found {records} records.&#34;)
        if df:
            result = pd.DataFrame(result)
            result.columns = [&#34;date&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        logger.info(&#34;End retrieve_location_level_values.&#34;)
        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cwmspy.cwms_level.CwmsLevelMixin"><code class="flex name class">
<span>class <span class="ident">CwmsLevelMixin</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CwmsLevelMixin:
    @ld
    def retrieve_location_level_values(
        self,
        p_location_level_id,
        p_start_time,
        p_end_time,
        p_level_units,
        p_timezone_id=&#34;GMT&#34;,
        p_office_id=&#34;NWDP&#34;,
        df=True,
    ):
        &#34;&#34;&#34;
        
        Retrieves a time series of location level values for a specified location level and a time window.

        Parameters
        ----------
        p_location_level_id : str
            The location level identifier. Format is location.parameter.parameter_type.duration.specified_level
        p_start_time : str 
            The start of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_end_time : str
            The end of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_level_units : str
            The value unit to retrieve the level values in
        p_timezone_id : str
            The time zone of the time window. Retrieved dates are also in this time zone (the default is &#34;GMT&#34;).
        p_office_id : str
            The office that owns the location level. If not specified or NULL, the session user&#39;s default office is used` (the default is &#34;NWDP&#34;).
        df : boolean
            Return a pandas.Core.DataFrame (the default is True).

        Returns
        -------
        type: either list or pandas.Core.DataFrame
        The location level values. The time series contains values at the spcified start and end times of the time window and may contain values at intermediate times
            * If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero
            * If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero
            * If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero
        The quality code of each returned value will be one of the following
            * 0: The value for all times between the previous value time and this one is the same as the previous value
            * 1: The value for all times between the previous value time and this one is interpolated between the previous value and this one
                
        
        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_level_units = &#39;cms&#39;
        &gt;&gt;&gt; p_start_time = &#39;01/01/2000&#39;
        &gt;&gt;&gt; p_end_time = &#39;05/01/2000&#39;
        &gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_cwms_ts_id=p_cwms_ts_id,
        &gt;&gt;&gt;                     p_start_time=p_start_time,
        &gt;&gt;&gt;                     p_end_time=p_end_time,
        &gt;&gt;&gt;                     p_level_units=p_level_units
        &gt;&gt;&gt;                     )
        ```

        &#34;&#34;&#34;

        try:
            cur = self.conn.cursor()

            bind_vars = {
                &#34;p_location_level_id&#34;: p_location_level_id,
                &#34;p_level_units&#34;: p_level_units,
                &#34;p_start_time&#34;: p_start_time,
                &#34;p_end_time&#34;: p_end_time,
                &#34;p_timezone_id&#34;: p_timezone_id,
                &#34;p_office_id&#34;: p_office_id,
            }

            logger.info(&#34;Start retrieve_location_level_values.&#34;)
            cur.execute(
                &#34;&#34;&#34;
                select * from table( cwms_level.retrieve_location_level_values(
                p_location_level_id =&gt;:p_location_level_id,
                p_level_units       =&gt;:p_level_units,
                p_start_time        =&gt;to_date( :p_start_time, &#39;dd-mm-yyyy hh24mi&#39; ),
                p_end_time          =&gt;to_date( :p_end_time, &#39;dd-mm-yyyy hh24mi&#39; ),
                p_timezone_id       =&gt;:p_timezone_id,
                p_office_id         =&gt;:p_office_id ) )&#34;&#34;&#34;,
                bind_vars,
            )
            records = cur.fetchall()
            cur.close()
        except Exception as e:
            logger.error(e)
            cur.close()
            # print bind_vars
            raise DatabaseError(e.__str__())
        result = []
        # The following code deals with the hacky location level API call that HEC
        # Implemented. The quality flag is an interpolation flag, meaning 0 is not
        # to be interopolated.
        lastVal = None
        for row in records:
            if row[2] == 0 and lastVal != None:
                result.append([row[0] - timedelta(minutes=1), lastVal, row[2]])
            result.append(row)
            lastVal = row[1]
        records = str(len(result))
        logger.info(f&#34;Found {records} records.&#34;)
        if df:
            result = pd.DataFrame(result)
            result.columns = [&#34;date&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        logger.info(&#34;End retrieve_location_level_values.&#34;)
        return result</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cwmspy.core.CWMS" href="core.html#cwmspy.core.CWMS">CWMS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_level_values"><code class="name flex">
<span>def <span class="ident">retrieve_location_level_values</span></span>(<span>self, p_location_level_id, p_start_time, p_end_time, p_level_units, p_timezone_id='GMT', p_office_id='NWDP', df=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves a time series of location level values for a specified location level and a time window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_location_level_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The location level identifier. Format is location.parameter.parameter_type.duration.specified_level</dd>
<dt><strong><code>p_start_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The start of the time window.
Format : 'dd-mm-yyyy hh24mi'.</dd>
<dt><strong><code>p_end_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The end of the time window.
Format : 'dd-mm-yyyy hh24mi'.</dd>
<dt><strong><code>p_level_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The value unit to retrieve the level values in</dd>
<dt><strong><code>p_timezone_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone of the time window. Retrieved dates are also in this time zone (the default is "GMT").</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the location level. If not specified or NULL, the session user's default office is used` (the default is "NWDP").</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Return a pandas.Core.DataFrame (the default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>either</code> <code>list</code> or <code>pandas.Core.DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><code>The</code> <code>location</code> <code>level</code> <code>values.</code> <code>The</code> <code>time</code> <code>series</code> <code>contains</code> <code>values</code> <code>at</code> <code>the</code> <code>spcified</code> <code>start</code> <code>and</code> <code>end</code> <code>times</code> of <code>the</code> <code>time</code> <code>window</code> <code>and</code> <code>may</code> <code>contain</code> <code>values</code> <code>at</code> <code>intermediate</code> <code>times</code></dt>
<dd>
<ul>
<li>If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero</li>
<li>If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero</li>
<li>If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero</li>
</ul>
</dd>
<dt><code>The</code> <code>quality</code> <code>code</code> of <code>each</code> <code>returned</code> <code>value</code> <code>will</code> <code>be</code> <code>one</code> of <code>the</code> <code>following</code></dt>
<dd>
<ul>
<li>0: The value for all times between the previous value time and this one is the same as the previous value</li>
<li>1: The value for all times between the previous value time and this one is interpolated between the previous value and this one</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; p_cwms_ts_id = 'Some.Fully.Qualified.Pathname'
&gt;&gt;&gt; p_level_units = 'cms'
&gt;&gt;&gt; p_start_time = '01/01/2000'
&gt;&gt;&gt; p_end_time = '05/01/2000'
&gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_cwms_ts_id=p_cwms_ts_id,
&gt;&gt;&gt;                     p_start_time=p_start_time,
&gt;&gt;&gt;                     p_end_time=p_end_time,
&gt;&gt;&gt;                     p_level_units=p_level_units
&gt;&gt;&gt;                     )
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@ld
def retrieve_location_level_values(
    self,
    p_location_level_id,
    p_start_time,
    p_end_time,
    p_level_units,
    p_timezone_id=&#34;GMT&#34;,
    p_office_id=&#34;NWDP&#34;,
    df=True,
):
    &#34;&#34;&#34;
    
    Retrieves a time series of location level values for a specified location level and a time window.

    Parameters
    ----------
    p_location_level_id : str
        The location level identifier. Format is location.parameter.parameter_type.duration.specified_level
    p_start_time : str 
        The start of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
    p_end_time : str
        The end of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
    p_level_units : str
        The value unit to retrieve the level values in
    p_timezone_id : str
        The time zone of the time window. Retrieved dates are also in this time zone (the default is &#34;GMT&#34;).
    p_office_id : str
        The office that owns the location level. If not specified or NULL, the session user&#39;s default office is used` (the default is &#34;NWDP&#34;).
    df : boolean
        Return a pandas.Core.DataFrame (the default is True).

    Returns
    -------
    type: either list or pandas.Core.DataFrame
    The location level values. The time series contains values at the spcified start and end times of the time window and may contain values at intermediate times
        * If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero
        * If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero
        * If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero
    The quality code of each returned value will be one of the following
        * 0: The value for all times between the previous value time and this one is the same as the previous value
        * 1: The value for all times between the previous value time and this one is interpolated between the previous value and this one
            
    
    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
    &gt;&gt;&gt; p_level_units = &#39;cms&#39;
    &gt;&gt;&gt; p_start_time = &#39;01/01/2000&#39;
    &gt;&gt;&gt; p_end_time = &#39;05/01/2000&#39;
    &gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_cwms_ts_id=p_cwms_ts_id,
    &gt;&gt;&gt;                     p_start_time=p_start_time,
    &gt;&gt;&gt;                     p_end_time=p_end_time,
    &gt;&gt;&gt;                     p_level_units=p_level_units
    &gt;&gt;&gt;                     )
    ```

    &#34;&#34;&#34;

    try:
        cur = self.conn.cursor()

        bind_vars = {
            &#34;p_location_level_id&#34;: p_location_level_id,
            &#34;p_level_units&#34;: p_level_units,
            &#34;p_start_time&#34;: p_start_time,
            &#34;p_end_time&#34;: p_end_time,
            &#34;p_timezone_id&#34;: p_timezone_id,
            &#34;p_office_id&#34;: p_office_id,
        }

        logger.info(&#34;Start retrieve_location_level_values.&#34;)
        cur.execute(
            &#34;&#34;&#34;
            select * from table( cwms_level.retrieve_location_level_values(
            p_location_level_id =&gt;:p_location_level_id,
            p_level_units       =&gt;:p_level_units,
            p_start_time        =&gt;to_date( :p_start_time, &#39;dd-mm-yyyy hh24mi&#39; ),
            p_end_time          =&gt;to_date( :p_end_time, &#39;dd-mm-yyyy hh24mi&#39; ),
            p_timezone_id       =&gt;:p_timezone_id,
            p_office_id         =&gt;:p_office_id ) )&#34;&#34;&#34;,
            bind_vars,
        )
        records = cur.fetchall()
        cur.close()
    except Exception as e:
        logger.error(e)
        cur.close()
        # print bind_vars
        raise DatabaseError(e.__str__())
    result = []
    # The following code deals with the hacky location level API call that HEC
    # Implemented. The quality flag is an interpolation flag, meaning 0 is not
    # to be interopolated.
    lastVal = None
    for row in records:
        if row[2] == 0 and lastVal != None:
            result.append([row[0] - timedelta(minutes=1), lastVal, row[2]])
        result.append(row)
        lastVal = row[1]
    records = str(len(result))
    logger.info(f&#34;Found {records} records.&#34;)
    if df:
        result = pd.DataFrame(result)
        result.columns = [&#34;date&#34;, &#34;value&#34;, &#34;quality_code&#34;]
    logger.info(&#34;End retrieve_location_level_values.&#34;)
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cwmspy" href="index.html">cwmspy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cwmspy.cwms_level.CwmsLevelMixin" href="#cwmspy.cwms_level.CwmsLevelMixin">CwmsLevelMixin</a></code></h4>
<ul class="">
<li><code><a title="cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_level_values" href="#cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_level_values">retrieve_location_level_values</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>