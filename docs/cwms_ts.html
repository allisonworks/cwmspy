<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>cwmspy.cwms_ts API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cwmspy.cwms_ts</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
import cx_Oracle
from cx_Oracle import DatabaseError
import datetime
import pandas as pd
from dateutil import tz
import pytz


class CwmsTsMixin:
    @staticmethod
    def _convert_to_local_time(date, timezone=&#34;UTC&#34;):
        # reference: https://stackoverflow.com/a/4771733/4296857
        if date == None:
            return None
        from_zone = tz.gettz(timezone)
        utc = date.replace(tzinfo=from_zone)
        local = utc.astimezone(tz.tzlocal()).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        local = datetime.datetime.strptime(local, &#34;%Y-%m-%d %H:%M:%S&#34;)
        return local

    def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
        &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.


        Args:
            p_cwms_ts_id: CWMS time series identifier
            p_db_office_code: The unique numeric code identifying the office
                               owning the time series

        Returns:
            ts_code: the unique numeric code value for the specified
                        time series if successful, False otherwise


        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:
            ts_code = cur.callfunc(
                &#34;cwms_ts.get_ts_code&#34;,
                cx_Oracle.STRING,
                [p_cwms_ts_id, p_db_office_code],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())

        cur.close()
        return ts_code

    def get_ts_max_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The latest non-null date in the time series

        Examples
        -------
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_ts_max_date(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        &gt;&gt;&gt; datetime.datetime(2019, 8, 16, 7, 0)

        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:
            max_date = cur.callfunc(
                &#34;cwms_ts.get_ts_max_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())

        cur.close()
        return max_date

    def get_ts_min_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest non-null date in the time series

        Examples
        -------
        &gt;&gt;&gt; import CWMS

        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()

        &gt;&gt;&gt; cwms.get_ts_min_date(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        
        datetime.datetime(1975, 2, 18, 8, 0)

        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:
            min_date = cur.callfunc(
                &#34;cwms_ts.get_ts_min_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())

        cur.close()
        return min_date

    def retrieve_ts(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        try:
            cur.callproc(
                &#34;cwms_ts.retrieve_ts&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]

        if local_tz:
            for i, v in enumerate(output):
                date = v[0]
                local = self._convert_to_local_time(date=date, timezone=p_timezone)

                output[i] = [local] + [x for x in v[1:]]

        if df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )

        return output

    def store_ts(
        self,
        p_cwms_ts_id,
        p_units,
        times,
        values,
        p_qualities,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database using parameter types
            compatible with cx_Oracle Pyton package.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit of the data values.
        p_times : list
            The UTC times of the data values.
        values : list
            The data values.
        p_qualities : list
            The data quality codes for the data values.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        &#34;&#34;&#34;

        cur = self.conn.cursor()

        p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

        t = [x.tz_localize(&#34;UTC&#34;) for x in times]
        zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
        p_times = [((time - zero).total_seconds() * 1000) for time in t]

        if not version_date:
            p_version_date = datetime.datetime(1111, 11, 11)
        else:
            p_version_date = version_date

        try:
            cur.callproc(
                &#34;cwms_ts.store_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_units,
                    p_times,
                    p_values,
                    p_qualities,
                    p_store_rule,
                    p_override_prot,
                    p_version_date,
                    p_office_id,
                ],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    def delete_ts(
        self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
    ):
        &#34;&#34;&#34;Deletes a time series from the database.

        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_delete_action : type
            Specifies what to delete.
        p_db_office_id : type
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..

        Returns
        -------
        Boolean
            True for success.

        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:
            cur.callproc(
                &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
            )
        except DatabaseError as e:
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    def rename_ts(
        self,
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
            regular interval offset.

            Restrictions on changing include:

                - New time series identifier must agree with new/existing data
                    interval and offset (regular/irregular)
                - Cannot change time utc offset if from one regular offset to
                    another if time series data exists

        Parameters
        ----------
        p_cwms_ts_id_old : str
            The existing time series identifier.
        p_cwms_ts_id_new : str
            The new time series identifier.
        p_utc_offset_new : int
            The new offset into the utc data interval in minutes.
        p_office_id : str
            The office that owns the time series. If not specified or NULL,
                the session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:
            cur.callproc(
                &#34;cwms_ts.rename_ts&#34;,
                [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    def delete_ts_window(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_override_protection=&#34;F&#34;,
        p_version_date=None,
        p_db_office_code=26,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_db_office_code : int
           The unique numeric code identifying the office owning the time
           series (the default is 26).

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; start_time = &#39;2018/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/2/1&#39;
        &gt;&gt;&gt; p_cwms_ts_id = &#39;your.cwms.ts.id&#39;
        &gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
                              p_override_protection=&#39;F&#39;, p_version_date=None,
                              p_db_office_code=26)
        &gt;&gt;&gt; True

        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        alter_session_sql = (
            &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
        )
        cur = self.conn.cursor()
        cur.execute(alter_session_sql)

        delete_sql = &#34;&#34;&#34;
                    delete from cwms_20.at_tsv_{}
                    where ts_code = {}
                    and date_time between to_date(&#39;{}&#39;) and to_date(&#39;{}&#39;)
                    &#34;&#34;&#34;
        if not p_override_protection:
            delete_sql += &#34;&#34;&#34;
                    and  quality_code not in (select quality_code from
                    cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                    &#34;&#34;&#34;

        ts_code = self.get_ts_code(
            p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
        )

        try:
            for year in range(p_start_time.year, (p_end_time.year + 1)):
                table = str(year)
                sql = delete_sql.format(table, ts_code, start_time, end_time)
                if p_version_date:
                    sql += &#34;and version_date = to_date(&#39;{}&#39;)&#34;.format(p_version_date)

                cur.execute(sql)
                cur.execute(&#34;commit&#34;)
        except Exception as e:
            cur.execute(&#34;rollback&#34;)
            cur.close()
            raise Exception(e.__str__())
        cur.close()
        return True

    def get_extents(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
            the database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : int
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest and latest non-null dates in the time series

        Examples
        -------
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_extents(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        &gt;&gt;&gt; (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))

        &#34;&#34;&#34;

        min_date = self.get_ts_min_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        max_date = self.get_ts_max_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        return min_date, max_date

    def get_por(
        self,
        p_cwms_ts_id,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        pd.core.frame.DataFrame or list
            The period of record for given time series identifier

        Examples
        -------
        ```python
        from cwmspy.core import CWMS
        cwms = CWMS()
        cwms.connect()
        df = cwms.get_por(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        df.head()
                    date_time        value  quality_code
        0 1975-02-18 08:00:00   750.396435             3
        1 1975-02-19 08:00:00   750.396435             3
        2 1975-02-20 08:00:00  1403.666086             3
        3 1975-02-21 08:00:00  1613.210750             0
        4 1975-02-22 08:00:00  1765.272217             0
        ```

        &#34;&#34;&#34;

        # p_version_date = datetime.datetime.strptime(version_date,
        # &#34;%Y/%m/%d&#34;)
        mn, mx = self.get_extents(
            p_cwms_ts_id=p_cwms_ts_id,
            p_time_zone=p_timezone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        # To get a little overlap
        mn = mn - datetime.timedelta(days=1)
        mx = mx + datetime.timedelta(days=1)

        start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
        end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

        return self.retrieve_ts(
            p_cwms_ts_id,
            start_time,
            end_time,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=&#34;F&#34;,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            df=df,
            local_tz=local_tz,
        )

    def retrieve_multi_ts(
        self,
        p_cwms_ts_id_list,
        start_time=None,
        end_time=None,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        df=True,
        local_tz=False,
        por=False,
        pivot=False,
    ):
        
        &#34;&#34;&#34;
        Retrieves time series data for a list of specified time series
            and time window or period of record.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        start_time : str
            The start of the time window in the specified or default time zone.
        end_time : str
            The end of the time window in the specified or default time zone.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        por : bool
            Return period of record.
        pivot : bool
            Pivot dataframe so cwms ts id&#39;s are columns.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;,
                             &#39;TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW&#39;]
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, &#39;2019/1/1&#39;, &#39;2019/9/1&#39;)
        &gt;&gt;&gt; df.head()
        ```
                        date_time                                ts_id       value  quality_code
            0 2018-12-31 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  574.831986             0
            1 2019-01-01 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  668.277580             0
            2 2019-01-02 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  608.812202             0
            3 2019-01-03 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  597.485463             0
            4 2019-01-04 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  560.673563             0

        ```
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
                                    &#39;2019/1/1&#39;,
                                    &#39;2019/9/1&#39;,
                                    pivot=True)
        &gt;&gt;&gt; df.head()
            ```
            ts_id                LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW
            date_time
            2018-12-31 08:00:00                           574.831986                                     NaN
            2018-12-31 23:00:00                                  NaN                                     0.0
            2019-01-01 00:00:00                                  NaN                                     0.0
            2019-01-01 01:00:00                                  NaN                                     0.0
            2019-01-01 02:00:00                                  NaN                                     0.0
            ```
        &#34;&#34;&#34;
        l = []
        for i, ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[i]
            else:
                p_units = None

            arg = [
                p_units,
                p_timezone,
                &#34;F&#34;,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                version_date,
                p_max_version,
                p_office_id,
                df,
                local_tz,
            ]

            if por:
                args0 = [ts_id]
                args = args0 + arg
                rslt = self.get_por(*args)
            else:
                args0 = [ts_id, start_time, end_time]
                args = args0 + arg
                rslt = self.retrieve_ts(*args)

            if df:
                rslt[&#34;ts_id&#34;] = ts_id

            l.append(rslt)

        if df:
            l = pd.concat(l, ignore_index=True)
            l = l[[&#34;date_time&#34;, &#34;ts_id&#34;, &#34;value&#34;, &#34;quality_code&#34;]]
            if pivot:
                l = l.pivot(index=&#34;date_time&#34;, columns=&#34;ts_id&#34;, values=&#34;value&#34;)
        return l

    
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cwmspy.cwms_ts.CwmsTsMixin"><code class="flex name class">
<span>class <span class="ident">CwmsTsMixin</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CwmsTsMixin:
    @staticmethod
    def _convert_to_local_time(date, timezone=&#34;UTC&#34;):
        # reference: https://stackoverflow.com/a/4771733/4296857
        if date == None:
            return None
        from_zone = tz.gettz(timezone)
        utc = date.replace(tzinfo=from_zone)
        local = utc.astimezone(tz.tzlocal()).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        local = datetime.datetime.strptime(local, &#34;%Y-%m-%d %H:%M:%S&#34;)
        return local

    def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
        &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.


        Args:
            p_cwms_ts_id: CWMS time series identifier
            p_db_office_code: The unique numeric code identifying the office
                               owning the time series

        Returns:
            ts_code: the unique numeric code value for the specified
                        time series if successful, False otherwise


        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:
            ts_code = cur.callfunc(
                &#34;cwms_ts.get_ts_code&#34;,
                cx_Oracle.STRING,
                [p_cwms_ts_id, p_db_office_code],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())

        cur.close()
        return ts_code

    def get_ts_max_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The latest non-null date in the time series

        Examples
        -------
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_ts_max_date(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        &gt;&gt;&gt; datetime.datetime(2019, 8, 16, 7, 0)

        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:
            max_date = cur.callfunc(
                &#34;cwms_ts.get_ts_max_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())

        cur.close()
        return max_date

    def get_ts_min_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest non-null date in the time series

        Examples
        -------
        &gt;&gt;&gt; import CWMS

        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()

        &gt;&gt;&gt; cwms.get_ts_min_date(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        
        datetime.datetime(1975, 2, 18, 8, 0)

        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:
            min_date = cur.callfunc(
                &#34;cwms_ts.get_ts_min_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())

        cur.close()
        return min_date

    def retrieve_ts(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        try:
            cur.callproc(
                &#34;cwms_ts.retrieve_ts&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]

        if local_tz:
            for i, v in enumerate(output):
                date = v[0]
                local = self._convert_to_local_time(date=date, timezone=p_timezone)

                output[i] = [local] + [x for x in v[1:]]

        if df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )

        return output

    def store_ts(
        self,
        p_cwms_ts_id,
        p_units,
        times,
        values,
        p_qualities,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database using parameter types
            compatible with cx_Oracle Pyton package.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit of the data values.
        p_times : list
            The UTC times of the data values.
        values : list
            The data values.
        p_qualities : list
            The data quality codes for the data values.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        &#34;&#34;&#34;

        cur = self.conn.cursor()

        p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

        t = [x.tz_localize(&#34;UTC&#34;) for x in times]
        zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
        p_times = [((time - zero).total_seconds() * 1000) for time in t]

        if not version_date:
            p_version_date = datetime.datetime(1111, 11, 11)
        else:
            p_version_date = version_date

        try:
            cur.callproc(
                &#34;cwms_ts.store_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_units,
                    p_times,
                    p_values,
                    p_qualities,
                    p_store_rule,
                    p_override_prot,
                    p_version_date,
                    p_office_id,
                ],
            )
        except DatabaseError as e:
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    def delete_ts(
        self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
    ):
        &#34;&#34;&#34;Deletes a time series from the database.

        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_delete_action : type
            Specifies what to delete.
        p_db_office_id : type
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..

        Returns
        -------
        Boolean
            True for success.

        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:
            cur.callproc(
                &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
            )
        except DatabaseError as e:
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    def rename_ts(
        self,
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
            regular interval offset.

            Restrictions on changing include:

                - New time series identifier must agree with new/existing data
                    interval and offset (regular/irregular)
                - Cannot change time utc offset if from one regular offset to
                    another if time series data exists

        Parameters
        ----------
        p_cwms_ts_id_old : str
            The existing time series identifier.
        p_cwms_ts_id_new : str
            The new time series identifier.
        p_utc_offset_new : int
            The new offset into the utc data interval in minutes.
        p_office_id : str
            The office that owns the time series. If not specified or NULL,
                the session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:
            cur.callproc(
                &#34;cwms_ts.rename_ts&#34;,
                [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
            )
        except DatabaseError as e:
            cur.close()
            raise DatabaseError(e.__str__())
        cur.close()
        return True

    def delete_ts_window(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_override_protection=&#34;F&#34;,
        p_version_date=None,
        p_db_office_code=26,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_db_office_code : int
           The unique numeric code identifying the office owning the time
           series (the default is 26).

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; start_time = &#39;2018/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/2/1&#39;
        &gt;&gt;&gt; p_cwms_ts_id = &#39;your.cwms.ts.id&#39;
        &gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
                              p_override_protection=&#39;F&#39;, p_version_date=None,
                              p_db_office_code=26)
        &gt;&gt;&gt; True

        &#34;&#34;&#34;

        p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
        p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

        alter_session_sql = (
            &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
        )
        cur = self.conn.cursor()
        cur.execute(alter_session_sql)

        delete_sql = &#34;&#34;&#34;
                    delete from cwms_20.at_tsv_{}
                    where ts_code = {}
                    and date_time between to_date(&#39;{}&#39;) and to_date(&#39;{}&#39;)
                    &#34;&#34;&#34;
        if not p_override_protection:
            delete_sql += &#34;&#34;&#34;
                    and  quality_code not in (select quality_code from
                    cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                    &#34;&#34;&#34;

        ts_code = self.get_ts_code(
            p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
        )

        try:
            for year in range(p_start_time.year, (p_end_time.year + 1)):
                table = str(year)
                sql = delete_sql.format(table, ts_code, start_time, end_time)
                if p_version_date:
                    sql += &#34;and version_date = to_date(&#39;{}&#39;)&#34;.format(p_version_date)

                cur.execute(sql)
                cur.execute(&#34;commit&#34;)
        except Exception as e:
            cur.execute(&#34;rollback&#34;)
            cur.close()
            raise Exception(e.__str__())
        cur.close()
        return True

    def get_extents(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
            the database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : int
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest and latest non-null dates in the time series

        Examples
        -------
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_extents(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        &gt;&gt;&gt; (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))

        &#34;&#34;&#34;

        min_date = self.get_ts_min_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        max_date = self.get_ts_max_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        return min_date, max_date

    def get_por(
        self,
        p_cwms_ts_id,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        df=True,
        local_tz=False,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.

        Returns
        -------
        pd.core.frame.DataFrame or list
            The period of record for given time series identifier

        Examples
        -------
        ```python
        from cwmspy.core import CWMS
        cwms = CWMS()
        cwms.connect()
        df = cwms.get_por(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
        df.head()
                    date_time        value  quality_code
        0 1975-02-18 08:00:00   750.396435             3
        1 1975-02-19 08:00:00   750.396435             3
        2 1975-02-20 08:00:00  1403.666086             3
        3 1975-02-21 08:00:00  1613.210750             0
        4 1975-02-22 08:00:00  1765.272217             0
        ```

        &#34;&#34;&#34;

        # p_version_date = datetime.datetime.strptime(version_date,
        # &#34;%Y/%m/%d&#34;)
        mn, mx = self.get_extents(
            p_cwms_ts_id=p_cwms_ts_id,
            p_time_zone=p_timezone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        # To get a little overlap
        mn = mn - datetime.timedelta(days=1)
        mx = mx + datetime.timedelta(days=1)

        start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
        end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

        return self.retrieve_ts(
            p_cwms_ts_id,
            start_time,
            end_time,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=&#34;F&#34;,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            df=df,
            local_tz=local_tz,
        )

    def retrieve_multi_ts(
        self,
        p_cwms_ts_id_list,
        start_time=None,
        end_time=None,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        df=True,
        local_tz=False,
        por=False,
        pivot=False,
    ):
        
        &#34;&#34;&#34;
        Retrieves time series data for a list of specified time series
            and time window or period of record.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        start_time : str
            The start of the time window in the specified or default time zone.
        end_time : str
            The end of the time window in the specified or default time zone.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        por : bool
            Return period of record.
        pivot : bool
            Pivot dataframe so cwms ts id&#39;s are columns.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;,
                             &#39;TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW&#39;]
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, &#39;2019/1/1&#39;, &#39;2019/9/1&#39;)
        &gt;&gt;&gt; df.head()
        ```
                        date_time                                ts_id       value  quality_code
            0 2018-12-31 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  574.831986             0
            1 2019-01-01 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  668.277580             0
            2 2019-01-02 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  608.812202             0
            3 2019-01-03 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  597.485463             0
            4 2019-01-04 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  560.673563             0

        ```
        &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
                                    &#39;2019/1/1&#39;,
                                    &#39;2019/9/1&#39;,
                                    pivot=True)
        &gt;&gt;&gt; df.head()
            ```
            ts_id                LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW
            date_time
            2018-12-31 08:00:00                           574.831986                                     NaN
            2018-12-31 23:00:00                                  NaN                                     0.0
            2019-01-01 00:00:00                                  NaN                                     0.0
            2019-01-01 01:00:00                                  NaN                                     0.0
            2019-01-01 02:00:00                                  NaN                                     0.0
            ```
        &#34;&#34;&#34;
        l = []
        for i, ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[i]
            else:
                p_units = None

            arg = [
                p_units,
                p_timezone,
                &#34;F&#34;,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                version_date,
                p_max_version,
                p_office_id,
                df,
                local_tz,
            ]

            if por:
                args0 = [ts_id]
                args = args0 + arg
                rslt = self.get_por(*args)
            else:
                args0 = [ts_id, start_time, end_time]
                args = args0 + arg
                rslt = self.retrieve_ts(*args)

            if df:
                rslt[&#34;ts_id&#34;] = ts_id

            l.append(rslt)

        if df:
            l = pd.concat(l, ignore_index=True)
            l = l[[&#34;date_time&#34;, &#34;ts_id&#34;, &#34;value&#34;, &#34;quality_code&#34;]]
            if pivot:
                l = l.pivot(index=&#34;date_time&#34;, columns=&#34;ts_id&#34;, values=&#34;value&#34;)
        return l</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cwmspy.core.CWMS" href="core.html#cwmspy.core.CWMS">CWMS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_ts"><code class="name flex">
<span>def <span class="ident">delete_ts</span></span>(<span>self, p_cwms_ts_id, p_delete_action='DELETE TS ID', p_db_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a time series from the database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the time series to delete.</dd>
<dt><strong><code>p_delete_action</code></strong> :&ensp;<code>type</code></dt>
<dd>Specifies what to delete.</dd>
<dt><strong><code>p_db_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office will be used..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_ts(
    self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
):
    &#34;&#34;&#34;Deletes a time series from the database.

    Parameters
    ----------
    p_cwms_ts_id : str
        The identifier of the time series to delete.
    p_delete_action : type
        Specifies what to delete.
    p_db_office_id : type
        The office that owns the time series. If not specified or NULL,
        the session user&#39;s default office will be used..

    Returns
    -------
    Boolean
        True for success.

    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:
        cur.callproc(
            &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
        )
    except DatabaseError as e:
        cur.close()
        raise DatabaseError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_ts_window"><code class="name flex">
<span>def <span class="ident">delete_ts_window</span></span>(<span>self, p_cwms_ts_id, start_time, end_time, p_override_protection='F', p_version_date=None, p_db_office_code=26)</span>
</code></dt>
<dd>
<section class="desc"><p>Short summary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The start time of the time window.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The end time of the time window.</dd>
<dt><strong><code>p_override_protection</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Description of parameter <code>p_office_id</code>.</dd>
<dt><strong><code>p_db_office_code</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>The unique numeric code identifying the office owning the time
series (the default is 26).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; start_time = '2018/1/1'
&gt;&gt;&gt; end_time = '2019/2/1'
&gt;&gt;&gt; p_cwms_ts_id = 'your.cwms.ts.id'
&gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
                      p_override_protection='F', p_version_date=None,


                  p_db_office_code=26)

&gt;&gt;&gt; True
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_ts_window(
    self,
    p_cwms_ts_id,
    start_time,
    end_time,
    p_override_protection=&#34;F&#34;,
    p_version_date=None,
    p_db_office_code=26,
):
    &#34;&#34;&#34;Short summary.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    start_time : str &#34;%Y/%m/%d&#34;
        The start time of the time window.
    end_time : str &#34;%Y/%m/%d&#34;
        The end time of the time window.
    p_override_protection : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        Description of parameter `p_office_id`.
    p_db_office_code : int
       The unique numeric code identifying the office owning the time
       series (the default is 26).

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; start_time = &#39;2018/1/1&#39;
    &gt;&gt;&gt; end_time = &#39;2019/2/1&#39;
    &gt;&gt;&gt; p_cwms_ts_id = &#39;your.cwms.ts.id&#39;
    &gt;&gt;&gt; cwms.delete_ts_window(p_cwms_ts_id, start_time, end_time,
                          p_override_protection=&#39;F&#39;, p_version_date=None,
                          p_db_office_code=26)
    &gt;&gt;&gt; True

    &#34;&#34;&#34;

    p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
    p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

    alter_session_sql = (
        &#34;ALTER SESSION SET NLS_DATE_FORMAT = &#39;YYYY-MM-DD HH24:MI:SS&#39;&#34;
    )
    cur = self.conn.cursor()
    cur.execute(alter_session_sql)

    delete_sql = &#34;&#34;&#34;
                delete from cwms_20.at_tsv_{}
                where ts_code = {}
                and date_time between to_date(&#39;{}&#39;) and to_date(&#39;{}&#39;)
                &#34;&#34;&#34;
    if not p_override_protection:
        delete_sql += &#34;&#34;&#34;
                and  quality_code not in (select quality_code from
                cwms_20.cwms_data_quality where validity_id = &#39;PROTECTED&#39;)
                &#34;&#34;&#34;

    ts_code = self.get_ts_code(
        p_cwms_ts_id=p_cwms_ts_id, p_db_office_code=p_db_office_code
    )

    try:
        for year in range(p_start_time.year, (p_end_time.year + 1)):
            table = str(year)
            sql = delete_sql.format(table, ts_code, start_time, end_time)
            if p_version_date:
                sql += &#34;and version_date = to_date(&#39;{}&#39;)&#34;.format(p_version_date)

            cur.execute(sql)
            cur.execute(&#34;commit&#34;)
    except Exception as e:
        cur.execute(&#34;rollback&#34;)
        cur.close()
        raise Exception(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_extents"><code class="name flex">
<span>def <span class="ident">get_extents</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the earliest and latest non-null time series data date in
the database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The earliest and latest non-null dates in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.get_extents('LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV')
&gt;&gt;&gt; (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_extents(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
        the database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : int
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The earliest and latest non-null dates in the time series

    Examples
    -------
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.get_extents(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
    &gt;&gt;&gt; (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))

    &#34;&#34;&#34;

    min_date = self.get_ts_min_date(
        p_cwms_ts_id,
        p_time_zone=p_time_zone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    max_date = self.get_ts_max_date(
        p_cwms_ts_id,
        p_time_zone=p_time_zone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    return min_date, max_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_por"><code class="name flex">
<span>def <span class="ident">get_por</span></span>(<span>self, p_cwms_ts_id, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, df=True, local_tz=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Short summary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_trim</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to trim missing values
from the beginning and end of the retrieved values.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.core.frame.DataFrame</code> or <code>list</code></dt>
<dd>The period of record for given time series identifier</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">from cwmspy.core import CWMS
cwms = CWMS()
cwms.connect()
df = cwms.get_por('LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV')
df.head()
            date_time        value  quality_code
0 1975-02-18 08:00:00   750.396435             3
1 1975-02-19 08:00:00   750.396435             3
2 1975-02-20 08:00:00  1403.666086             3
3 1975-02-21 08:00:00  1613.210750             0
4 1975-02-22 08:00:00  1765.272217             0
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_por(
    self,
    p_cwms_ts_id,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    df=True,
    local_tz=False,
):
    &#34;&#34;&#34;Short summary.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.

    Returns
    -------
    pd.core.frame.DataFrame or list
        The period of record for given time series identifier

    Examples
    -------
    ```python
    from cwmspy.core import CWMS
    cwms = CWMS()
    cwms.connect()
    df = cwms.get_por(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
    df.head()
                date_time        value  quality_code
    0 1975-02-18 08:00:00   750.396435             3
    1 1975-02-19 08:00:00   750.396435             3
    2 1975-02-20 08:00:00  1403.666086             3
    3 1975-02-21 08:00:00  1613.210750             0
    4 1975-02-22 08:00:00  1765.272217             0
    ```

    &#34;&#34;&#34;

    # p_version_date = datetime.datetime.strptime(version_date,
    # &#34;%Y/%m/%d&#34;)
    mn, mx = self.get_extents(
        p_cwms_ts_id=p_cwms_ts_id,
        p_time_zone=p_timezone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    # To get a little overlap
    mn = mn - datetime.timedelta(days=1)
    mx = mx + datetime.timedelta(days=1)

    start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
    end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

    return self.retrieve_ts(
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=p_units,
        p_timezone=p_timezone,
        p_trim=&#34;F&#34;,
        p_start_inclusive=p_start_inclusive,
        p_end_inclusive=p_end_inclusive,
        p_previous=p_previous,
        p_next=p_next,
        version_date=version_date,
        p_max_version=p_max_version,
        p_office_id=p_office_id,
        df=df,
        local_tz=local_tz,
    )</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_code"><code class="name flex">
<span>def <span class="ident">get_ts_code</span></span>(<span>self, p_cwms_ts_id, p_db_office_code=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the CWMS TS Code of a given pathname.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong></dt>
<dd>CWMS time series identifier</dd>
<dt><strong><code>p_db_office_code</code></strong></dt>
<dd>The unique numeric code identifying the office
owning the time series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ts_code</code></strong></dt>
<dd>the unique numeric code value for the specified
time series if successful, False otherwise</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
    &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.


    Args:
        p_cwms_ts_id: CWMS time series identifier
        p_db_office_code: The unique numeric code identifying the office
                           owning the time series

    Returns:
        ts_code: the unique numeric code value for the specified
                    time series if successful, False otherwise


    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:
        ts_code = cur.callfunc(
            &#34;cwms_ts.get_ts_code&#34;,
            cx_Oracle.STRING,
            [p_cwms_ts_id, p_db_office_code],
        )
    except DatabaseError as e:
        cur.close()
        raise ValueError(e.__str__())

    cur.close()
    return ts_code</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date"><code class="name flex">
<span>def <span class="ident">get_ts_max_date</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the latest non-null time series data date in the
database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The latest non-null date in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.get_ts_max_date('LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV')
&gt;&gt;&gt; datetime.datetime(2019, 8, 16, 7, 0)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_ts_max_date(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
        database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : type
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The latest non-null date in the time series

    Examples
    -------
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.get_ts_max_date(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
    &gt;&gt;&gt; datetime.datetime(2019, 8, 16, 7, 0)

    &#34;&#34;&#34;
    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    cur = self.conn.cursor()
    try:
        max_date = cur.callfunc(
            &#34;cwms_ts.get_ts_max_date&#34;,
            cx_Oracle.DATETIME,
            [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
        )
    except DatabaseError as e:
        cur.close()
        raise ValueError(e.__str__())

    cur.close()
    return max_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date"><code class="name flex">
<span>def <span class="ident">get_ts_min_date</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves the earliest non-null time series data date in the
database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The earliest non-null date in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import CWMS

&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()

&gt;&gt;&gt; cwms.get_ts_min_date('LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV')
</code></pre>
<p>datetime.datetime(1975, 2, 18, 8, 0)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_ts_min_date(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
        database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : type
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The earliest non-null date in the time series

    Examples
    -------
    &gt;&gt;&gt; import CWMS

    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()

    &gt;&gt;&gt; cwms.get_ts_min_date(&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;)
    
    datetime.datetime(1975, 2, 18, 8, 0)

    &#34;&#34;&#34;
    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    cur = self.conn.cursor()
    try:
        min_date = cur.callfunc(
            &#34;cwms_ts.get_ts_min_date&#34;,
            cx_Oracle.DATETIME,
            [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
        )
    except DatabaseError as e:
        cur.close()
        raise ValueError(e.__str__())

    cur.close()
    return min_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.rename_ts"><code class="name flex">
<span>def <span class="ident">rename_ts</span></span>(<span>self, p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new=None, p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Renames a time series in the database, optionally setting a new
regular interval offset.</p>
<pre><code>Restrictions on changing include:

    - New time series identifier must agree with new/existing data
        interval and offset (regular/irregular)
    - Cannot change time utc offset if from one regular offset to
        another if time series data exists
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_old</code></strong> :&ensp;<code>str</code></dt>
<dd>The existing time series identifier.</dd>
<dt><strong><code>p_cwms_ts_id_new</code></strong> :&ensp;<code>str</code></dt>
<dd>The new time series identifier.</dd>
<dt><strong><code>p_utc_offset_new</code></strong> :&ensp;<code>int</code></dt>
<dd>The new offset into the utc data interval in minutes.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rename_ts(
    self,
    p_cwms_ts_id_old,
    p_cwms_ts_id_new,
    p_utc_offset_new=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
        regular interval offset.

        Restrictions on changing include:

            - New time series identifier must agree with new/existing data
                interval and offset (regular/irregular)
            - Cannot change time utc offset if from one regular offset to
                another if time series data exists

    Parameters
    ----------
    p_cwms_ts_id_old : str
        The existing time series identifier.
    p_cwms_ts_id_new : str
        The new time series identifier.
    p_utc_offset_new : int
        The new offset into the utc data interval in minutes.
    p_office_id : str
        The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office is used.

    Returns
    -------
    Boolean
        True for success.

    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:
        cur.callproc(
            &#34;cwms_ts.rename_ts&#34;,
            [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
        )
    except DatabaseError as e:
        cur.close()
        raise DatabaseError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_multi_ts"><code class="name flex">
<span>def <span class="ident">retrieve_multi_ts</span></span>(<span>self, p_cwms_ts_id_list, start_time=None, end_time=None, p_units_list=None, p_timezone='UTC', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, df=True, local_tz=False, por=False, pivot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves time series data for a list of specified time series
and time window or period of record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of time series identifiers.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The start of the time window in the specified or default time zone.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The end of the time window in the specified or default time zone.</dd>
<dt><strong><code>p_units_list</code></strong> :&ensp;<code>list</code></dt>
<dd>Unit list to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
<dt><strong><code>por</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return period of record.</dd>
<dt><strong><code>pivot</code></strong> :&ensp;<code>bool</code></dt>
<dd>Pivot dataframe so cwms ts id's are columns.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas</code> <code>df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; from cwmspy.core import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; p_cwms_ts_id_list = ['LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV',
                     'TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW']
&gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, '2019/1/1', '2019/9/1')
&gt;&gt;&gt; df.head()
```


            date_time                                ts_id       value  quality_code
0 2018-12-31 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  574.831986             0
1 2019-01-01 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  668.277580             0
2 2019-01-02 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  608.812202             0
3 2019-01-03 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  597.485463             0
4 2019-01-04 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  560.673563             0
</code></pre>
<p>```</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
'2019/1/1',
'2019/9/1',
pivot=True)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>&gt;&gt;&gt; df.head()
    ```


ts_id                LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW
date_time
2018-12-31 08:00:00                           574.831986                                     NaN
2018-12-31 23:00:00                                  NaN                                     0.0
2019-01-01 00:00:00                                  NaN                                     0.0
2019-01-01 01:00:00                                  NaN                                     0.0
2019-01-01 02:00:00                                  NaN                                     0.0
```
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def retrieve_multi_ts(
    self,
    p_cwms_ts_id_list,
    start_time=None,
    end_time=None,
    p_units_list=None,
    p_timezone=&#34;UTC&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    df=True,
    local_tz=False,
    por=False,
    pivot=False,
):
    
    &#34;&#34;&#34;
    Retrieves time series data for a list of specified time series
        and time window or period of record.

    Parameters
    ----------
    p_cwms_ts_id_list : list
        List of time series identifiers.
    start_time : str
        The start of the time window in the specified or default time zone.
    end_time : str
        The end of the time window in the specified or default time zone.
    p_units_list : list
        Unit list to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.
    por : bool
        Return period of record.
    pivot : bool
        Pivot dataframe so cwms ts id&#39;s are columns.

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.

    Examples
    -------
    &gt;&gt;&gt; from cwmspy.core import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV&#39;,
                         &#39;TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW&#39;]
    &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list, &#39;2019/1/1&#39;, &#39;2019/9/1&#39;)
    &gt;&gt;&gt; df.head()
    ```
                    date_time                                ts_id       value  quality_code
        0 2018-12-31 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  574.831986             0
        1 2019-01-01 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  668.277580             0
        2 2019-01-02 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  608.812202             0
        3 2019-01-03 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  597.485463             0
        4 2019-01-04 08:00:00  LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  560.673563             0

    ```
    &gt;&gt;&gt; df = cwms.retrieve_multi_ts(p_cwms_ts_id_list,
                                &#39;2019/1/1&#39;,
                                &#39;2019/9/1&#39;,
                                pivot=True)
    &gt;&gt;&gt; df.head()
        ```
        ts_id                LWG.Flow-Out.Ave.~1Day.1Day.CBT-REV  TDA.Flow-Spill.Ave.1Hour.1Hour.CBT-RAW
        date_time
        2018-12-31 08:00:00                           574.831986                                     NaN
        2018-12-31 23:00:00                                  NaN                                     0.0
        2019-01-01 00:00:00                                  NaN                                     0.0
        2019-01-01 01:00:00                                  NaN                                     0.0
        2019-01-01 02:00:00                                  NaN                                     0.0
        ```
    &#34;&#34;&#34;
    l = []
    for i, ts_id in enumerate(p_cwms_ts_id_list):
        if p_units_list:
            p_units = p_units_list[i]
        else:
            p_units = None

        arg = [
            p_units,
            p_timezone,
            &#34;F&#34;,
            p_start_inclusive,
            p_end_inclusive,
            p_previous,
            p_next,
            version_date,
            p_max_version,
            p_office_id,
            df,
            local_tz,
        ]

        if por:
            args0 = [ts_id]
            args = args0 + arg
            rslt = self.get_por(*args)
        else:
            args0 = [ts_id, start_time, end_time]
            args = args0 + arg
            rslt = self.retrieve_ts(*args)

        if df:
            rslt[&#34;ts_id&#34;] = ts_id

        l.append(rslt)

    if df:
        l = pd.concat(l, ignore_index=True)
        l = l[[&#34;date_time&#34;, &#34;ts_id&#34;, &#34;value&#34;, &#34;quality_code&#34;]]
        if pivot:
            l = l.pivot(index=&#34;date_time&#34;, columns=&#34;ts_id&#34;, values=&#34;value&#34;)
    return l</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts"><code class="name flex">
<span>def <span class="ident">retrieve_ts</span></span>(<span>self, p_cwms_ts_id, start_time, end_time, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, df=True, local_tz=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves time series data for a specified time series and
time window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier to retrieve data for.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The start time of the time window.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str</code> <code>"</code>%<code>Y</code>/%<code>m</code>/%<code>d"</code></dt>
<dd>The end time of the time window.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_trim</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to trim missing values
from the beginning and end of the retrieved values.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas</code> <code>df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def retrieve_ts(
    self,
    p_cwms_ts_id,
    start_time,
    end_time,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    df=True,
    local_tz=False,
):
    &#34;&#34;&#34;Retrieves time series data for a specified time series and
        time window.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier to retrieve data for.
    start_time : str &#34;%Y/%m/%d&#34;
        The start time of the time window.
    end_time : str &#34;%Y/%m/%d&#34;
        The end time of the time window.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.

    &#34;&#34;&#34;

    p_start_time = datetime.datetime.strptime(start_time, &#34;%Y/%m/%d&#34;)
    p_end_time = datetime.datetime.strptime(end_time, &#34;%Y/%m/%d&#34;)

    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)

    cur = self.conn.cursor()
    p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
    try:
        cur.callproc(
            &#34;cwms_ts.retrieve_ts&#34;,
            [
                p_at_tsv_rc,
                p_cwms_ts_id,
                p_units,
                p_start_time,
                p_end_time,
                p_timezone,
                p_trim,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                p_version_date,
                p_max_version,
                p_office_id,
            ],
        )

    except DatabaseError as e:
        cur.close()
        raise ValueError(e.__str__())
    cur.close()

    output = [r for r in p_at_tsv_rc.getvalue()]

    if local_tz:
        for i, v in enumerate(output):
            date = v[0]
            local = self._convert_to_local_time(date=date, timezone=p_timezone)

            output[i] = [local] + [x for x in v[1:]]

    if df:
        output = pd.DataFrame(
            output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        )

    return output</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.store_ts"><code class="name flex">
<span>def <span class="ident">store_ts</span></span>(<span>self, p_cwms_ts_id, p_units, times, values, p_qualities, p_store_rule='REPLACE ALL', p_override_prot='F', version_date=None, p_office_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Stores time series data to the database using parameter types
compatible with cx_Oracle Pyton package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit of the data values.</dd>
<dt><strong><code>p_times</code></strong> :&ensp;<code>list</code></dt>
<dd>The UTC times of the data values.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>The data values.</dd>
<dt><strong><code>p_qualities</code></strong> :&ensp;<code>list</code></dt>
<dd>The data quality codes for the data values.</dd>
<dt><strong><code>p_store_rule</code></strong> :&ensp;<code>type</code></dt>
<dd>The store rule to use.</dd>
<dt><strong><code>p_override_prot</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Description of parameter <code>p_office_id</code>.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office owning the time series. If not specified or NULL, the
session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def store_ts(
    self,
    p_cwms_ts_id,
    p_units,
    times,
    values,
    p_qualities,
    p_store_rule=&#34;REPLACE ALL&#34;,
    p_override_prot=&#34;F&#34;,
    version_date=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Stores time series data to the database using parameter types
        compatible with cx_Oracle Pyton package.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_units : str
        The unit of the data values.
    p_times : list
        The UTC times of the data values.
    values : list
        The data values.
    p_qualities : list
        The data quality codes for the data values.
    p_store_rule : type
        The store rule to use.
    p_override_prot : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        Description of parameter `p_office_id`.
    p_office_id : type
        The office owning the time series. If not specified or NULL, the
        session user&#39;s default office is used.

    Returns
    -------
    Boolean
        True for success.

    &#34;&#34;&#34;

    cur = self.conn.cursor()

    p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

    t = [x.tz_localize(&#34;UTC&#34;) for x in times]
    zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
    p_times = [((time - zero).total_seconds() * 1000) for time in t]

    if not version_date:
        p_version_date = datetime.datetime(1111, 11, 11)
    else:
        p_version_date = version_date

    try:
        cur.callproc(
            &#34;cwms_ts.store_ts&#34;,
            [
                p_cwms_ts_id,
                p_units,
                p_times,
                p_values,
                p_qualities,
                p_store_rule,
                p_override_prot,
                p_version_date,
                p_office_id,
            ],
        )
    except DatabaseError as e:
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cwmspy" href="index.html">cwmspy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cwmspy.cwms_ts.CwmsTsMixin" href="#cwmspy.cwms_ts.CwmsTsMixin">CwmsTsMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_ts">delete_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_ts_window" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_ts_window">delete_ts_window</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_extents" href="#cwmspy.cwms_ts.CwmsTsMixin.get_extents">get_extents</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_por" href="#cwmspy.cwms_ts.CwmsTsMixin.get_por">get_por</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_code" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_code">get_ts_code</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date">get_ts_max_date</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date">get_ts_min_date</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.rename_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.rename_ts">rename_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_multi_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_multi_ts">retrieve_multi_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts">retrieve_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.store_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.store_ts">store_ts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>